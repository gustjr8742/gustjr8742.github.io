# 파이썬 기본문법 총 정리 with(코딩테스트)

코딩테스트를 알아보면서, 자바로 코테를 준비하기에는 오랜 시간이
걸린다는 것을 깨달았다.

물론, 나중에 자바로도 준비를 해야겠지만 급한건 우선 취업을 위해 코테를 통과해야하므로... 그리고 요즘 파이썬이 대세이기도 하다.

기본 문법은 다른 언어들과 크게 다르지 않으니 하루만에 완독하고 습득한후
코테를 준비해보자!

_ _ _

정수형 데이터.
보통 코딩테스트에 나오는 숫자들은 정수형이다.
EX) a = 100 , print(a) --> 100 출력

실수형 데이터.
EX) a = 157.93 , print(a) --> 157.93

실수형 데이터를 표현하는 방식으로, 파이썬에서는 e나 E를 사용한다.
예를들어 1e9라고 입력하게 되면, 10의 9제곱이 된다.
-> 유효숫자e^지수 = 유효숫자x10^지수

지수 표현 방식은 코테에서 많이 사용된다.
예를 들어 최단 경로 문제에서는 도달할 수 없는 노드에 대하여 최단 거리를 '무한(INF)'으로 설정하곤 한다.
최단 경로로 가능한 최댓값이 10억 미만이라면 무한(INF)을 표현할때
10억을 이용할 수 있다. 이때 일일이 10억을 특정 변수에 대입하는 것은 번거롭기 때문에 1e9로 표현한다.
EX) a = 1e9 , print(a) --> 100000000.0 출력(10억)
a = 75.25e1 , print(a) --> 752.5
a = 3954e-3 , print(a) --> 3.954

보통 컴퓨터는 이진수로 데이터를 처리한다.
따라서 0.3 + 0.6은 0.9가 아니라 0.8999999로 출력된다.
a = 0.3 + 0.6

if a == 0.9:
print(True)
else:
print(False)
출력값 --> 0.8999999999999 Flase

소수점 값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지 못한다.
원하는결과를 얻기가 힘들다. 이럴때는 round() 함수를 이용한다.

- round()함수
이 함수를 호출할 때는 인자를 넣는데 첫 번째 인자는 실수형 데이터,
두 번째 인자는 [반올림하고자 하는 위치 -1] 이다.
예를 들어 123.456을 소수점 셋째 자리에서 반올림하려면
round(123.456,2) 라고 작성하며 결과는 123.46이다.


- 수 자료형의 연산
프로그래밍에서는 사칙연산을 이용해 계사ㅣㄴ한다.
이 중에서 나누기 연산자를 주의한다.
파이썬에서는 나누기 연산자를 기본적으로 실수형으로 처리한다.
코딩 테스트를 풀이할 때에는 나머지 연산자(%)를 이용해야 할 때가 많은데
예를 들어 특정한 변수 a 가 홀수인지 알아볼 때에는 'a를 2로 나눈 나머지가 1인지' 확인한다.
몫만을 얻고자 할때는 몫 연산자(//)를 이용한다.
EX) a=7 b=3
print(a/b) --> 2.33333333335
print(a%b) --> 1
print(a//b)--> 2

이외에도 거듭제곱 연산자를 비롯해 다양한 연산자들이 존재한다.
거듭제곱 연산자는 x**y형식으로 사용되는데, 이는 x^y를 의미한다.

EX) a = 5, b = 3 print(a**b) --> 5^3인 125 출력


_ _ _

####리스트 자료형

리스트는 자바나 C의 배열이라고 생각하면 될듯 하다.
내부적으로 연결 리스트 자료구조를 택하고 있어서 append(), remove()
등의 메서드를 지원한다.
리스트 대신에 배열 혹인 테이블아리고 부르기도 한다.

리스트는 대괄후([]) 안에 원소를 넣어 초기화하며, 쉼표(,)로 구분한다.
원소에 접근할 때는 인덱스 값을 괄호 안에 넣는다.
(인덱스는 0부터 시작한다.)
비어 있는 리스트를 선언하고자 할 때는 list()혹은 간단히 대괄호([])
를 이용할 수 있다.
EX) a =[1,2,3,4,5,6,7,8,9]
print(a) -->[1,2,3,4,5,6,7,8,9]출력
print(a[4]) --> 5 (0부터 시작하므로 5번째에 있는 5 출력)
a = list() ,print(a) -->[] (빈 리스트 선언 방법)
a = [] , print(a) -->[] (빈 리스트 선언 방법 2)

코딩 테스트 문제에서는 주로 크기가 N인 1차원 리스트를 초기화 해야 한다.
크기가 N이고 모든 값이 0인 1차원 리스트를 초기화 하는 소스 코드는 다음과 같다.
n = 10
a = [0]*n
print(a) 
출력값 : [0,0,0,0,0,0,0,0,0,0]

####리스트의 인덱싱과 슬라이싱
인덱스 값을 입력하여 특정한 리스트의 특정한 원소에 접근하는 것을 인덱싱이라고 한다.
파이썬의 인덱스 값은 양의 정수와 음의 정수 모두 사용할 수 있으며
음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다.

예를 들어 인덱스에 -1을 넣으면 마지막 원소가 출력된다.
예시를 보자
EX) a = [1,2,3,4,5,6,7,8,9]
print(a[-1]) --> 9 
print(a[-3]) --> 7
a[3] = 7, print(a) --> [1.2.3.7.5.6.7.8.9] (네 번째 원소 변경)

연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 할 수있다.
대괄호 안에 클론을 넣어서 시작 인덱스와 [끝 인덱스 - 1] 을 설정할 수 있다.
예시를 보자
EX) a = [1,2,3,4,5,6,7,8,9]
print(a[1:4]) --> [2,3,4] 출력 (4를 작성했으므로 3번째까지 출력)

#### 리스트 컴프리헨션

리스트 컴프리헨션은 리스트를 초기화하는 방법 중 하나이다.
대괄호([]) 안에 조건문과 반복문을 넣는 방식으로
리스트를 초기화할 수 있다.
EX) array = [i for i in range(20) if i % 2 == 1]

print(array) -->[1,3,5,7,9,11,13,15,17,19]
0부터 10까지의 수 중에서 홀수만 포함하는 리스트를 만들었다.

참고로 위 소스코드를 일반적인 소스코드로 작성하면 다음과 같다.
array = []
for i in range(20):
if i % 2 == 1:
array.append(i)

print(array)

또 다른 예시로 1부터 9까지 수의 제곱 값을 포함하는 리스트를
만들고자 할 때는 다음과 같이 리스트를 초기화 할 수 있다.
array = [i*i for i in range(1,10)]
print(array) --> [1,4,9,16,25,36,49,64,81]

이러한 리스트 컴프리헨션은 코딩 테스트에서 2차원 리스트를 초기화할 때
매우 효과적으로 사용될 수 있다.
예를 들어 N곱하기M 크기의 2차원 리스트를 초기화할때 다음과 같다.
n=3
m=4
array = [[0]  m for _ in range(n)]
print(array)
출력값 --> [[0,0,0,0],[0,0,0,0],[0,0,0,0]]

여기서 언더바는 변수의 값을 무시할 때 사용한다
예를 들어 단순히 Hello World를 5번 출력할 때는
for _ in range(5):
print("Hello World") 로 하면된다.

참고로 특정 크기의 2차원 리스트를 초기화할 때는 반드시
리스트 컴프리헨션을 이용해야 한다.
n=3
m=4
array =[[0] ******* m] ***** n
print(array)
출력값 --> [[0,0,0,0],[0,0,0,0],[0,0,0,0]]
array[1][1] = 5
print(array)
출력값 -> [[0,5,0,0],[0,5,0,0],[0,5,0,0]]

이처럼 3개의 리스트에서 인덱스 1에 해당하는 원소들의 값이
모두 5로 바뀐 것을 확인할 수 있다.
이는 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한
3개의 레퍼런스로 인식되기 때문이다.
따라서 특정한 크기를 가지는 2차원 리스트를 초기화할 때에는
리스트 컴프리헨션을 이용해야한다는 점을 기억해야 한다.

#####리스트 관련 기타 메서드

**append() --> 변수명.append()** 
// 리스트에 원소를 하나 삽입할 때 사용한다.
**sort() --> 변수명.sort()**
//기본 정렬 기능으로 오름차순으로 정렬한다.
(변수명.sort(reverse=True)내림차순)
**reverse() --> 변수명.reverse()**
//리스트의 원소의 순서를 모두 뒤집어 놓는다.
**insert() --> 변수명.insert(삽입할 위치 인덱스, 삽입할 값)**
//특정한 인덱스 위치에 원소를 삽입한다.
**count() --> 변수명.count(특정 값)**
//리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용
**remove() --> 변수명.remove(특정 값)**
//특정한 값을 갖는 원소를 제고하는데, 값을 가진 원소가 여러 개면
하나만 제거한다.

EX)
a = [1,4,3]
print("기본리스트: ", a) --> 기본리스트 : [1,4,3]

a.append(2)
prunt("삽입 : ", a) --> 삽입 : [1,4,3,2]

a.sort()
print("오름차순 정렬: " , a)  --> 오름차순 정렬 : [1,2,3,4]

a.sort(reverse = True)
print("내림차순 정렬: ",a) --> 내림차순 정렬 : [4,3,2,1]

a.reverse()
print("원소 뒤집기: ", a) --> 원소 뒤집기 : [1,2,3,4]

a.insert(2,3)
print("인덱스 2에 3 추가:" a) --> [1,2,3,3,4]

print("값이 3인 데이터 개수: " ,a.count(3)) -->2

a.remove(1)
print("값이 1인 데이터 삭제:",a)  --> [2,3,3,4]

**이 중에서 insert() 함수와 append(),remove()를 눈여겨두자**

코딩 테스트에서 insert() 함수를 사용할 때 원소의 개수가 N개면
시간 복잡도는 O(N)이다. 파이썬의 리스트 자료형의 append() 함수는
O(1)에 수행되는데 반해 insert() 함수는 동작이 느리다.
중간에 원소를 삽입한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문이다.
따라서 insert() 함수를 남발하면 '시간 초과'로 테스트를 통과하지 못할 수도 있다.

remove의 시간 복잡도는 insert()함수와 마찬가지로 O(N)이다.

**특정한 값의 원소를 모두 제거하려면 어떻게 해야할까?**
(remove를 남발하면 안되는 이유는 위에서 배웠다.)

a = [1,2,3,4,5,5,5]
remove_set = {3,5}

result = [i for i in a if i not in remove_set]
print(result)
출력 값 --> [1,2,4]

다음 코드에서 result 부분은 a에 포함된 원소를 하나씩 확인하며
그 원소가 remove_set에 포함되어 있지 않았을 때만
리스트 변수인 result에 넣겠다는 의미이다.

_ _ _
#### 문자열 자료형

**문자열 초기화**

문자열 변수를 초기화할 때는 큰따옴표(")나 작은따옴표(')를 사용한다.
큰 따옴표나 작은 따옴표는 백슬래시(\)를 사용하면 문자열에 포함시킬 수 있다.
(기본적으로 큰따옴표로 구성하면 작은 따옴표 사용가능 반대도 가능!)

data = 'Hello World'
print(data) --> Hellow world

data = "Don't you know \"Python\"?"
print(data) --> Don't you know \"Python\"?'

**문자열 연산**
파이썬은 문자열에 대한 연산도 지원하는데 문자열을 처리할 때 유용하게 사용할 수 있다.
예를들어 문자열 변수에 덧셈을 이용하면 문자열이 더해진다 (단순하다.)

a = "Hello"
b = "World"

print(a + " " + b) --> Hello World

문자열 변수를 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해진다.

a = "String"
print(a*3) --> StringStringString

파이썬의 문자열은 내부적으로 리스트와 같이 처리된다.
따라서 문자열도 인덱싱과 슬라이싱을 할 수 있다.

a = "ABCDEF"

print(a[2:4]) --> CD

**튜플 자료형**

파이썬의 튜플 자료형은 리스트와 거의 비슷한데 다음과 같은 차이가 있다.

 - 튜플은 한번 선언된 값을 변경할 수 없다.
 - 리스트는 대괄호를 이용하지만, 튜플은 소괄호를 이용한다.

튜플의 예시를 보자.
a = (1,2,3,4)
print(a)
a[2] = 7
출력값 --> (1,2,3,4)
Traceback (most recent call last):
File "main.py", line4, in<module>
a[2] = 7
TypeError: 'tuple' object does not supprot item assignment
위는 에러가 났다는 뜻이다.

튜플의 값(1,2,3,4)는 그대로 출력된다.
하지만 특정한 값을 변경하려고 하면 오류가 발생된다.
튜플 자료형은 그래프 알고리즘을 구현할 때 자주 사용된다.
예를 들어 다익스트라 최단 경로 알고리즘처럼
최단 경로를 찾아주는 알고리즘의 내부에서는 우선순위 큐를 이용하는데
해당 알고리즘에서 우선순위 큐에 한 번 들어간 값은 변경되지 않는다.
그래서 우선순위 큐에 들어가는 데이터를 튜플로 구성하여 소스코드를 작성한다.
또한 튜플은 리스트에 비해 상대적으로 공간 효율적이고,
일반적으로 각 원소의 성질이 서로 다를 때 주로 사용한다.
흔히 다익스트라 최단 경로 알고리즘에서는 '비용'과 '노드 번호'라는
서로 다른 성질의 데이터를 (비용, 노드 번호)의 형태로 함께 튜플로
묶어서 관리하는 것이 관례이다.

(사실 지금 이 글을 잘 모르겠지만 알고리즘 공부하면 알게되겠지..)

#### 사전 자료형

사전 자료형은 키와 값의 쌍을 데이터로 가지는 자료형이다.
예를 들어 다음과 같이 키-값 쌍으로 구성되는 데이터를
담아야 한다면 어떻게 할 수 있을까?
키 값
사과 - Apple
바나나 - Banana
코코넛 - Coconut
키로 한글 단어를 넣고, 값으로 영어 단어를 넣어 '사과'의 영어 단어를 알고 싶다면 '사과'라는 키 값을 가지는 데이터에 바로 접근하면 된다.
파이썬의 사전 자료형은 내부적으로 '해시 테이블'을 이용하므로
기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

EX)
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data) --> {'사과': 'Aplle', '바나나':'Banana', '코코넛':'Coconut'}
이러한 사전 자료형은 코딩 테스트에서도 자주 사용될 수 있다.
예를 들어 번호가 1부터 10,000,000까지로 구성되어 있는 상황에서
최대 10,000명의 학생을 선택했다고 가정하자.
이후에 특정한 학생 번호가 주어졌을 때 해당 학생이 선택되었는지를
어떻게 빠르게 알 수 있을까?
만약 리스트를 이용한다면, 1부터 10,000,000까지의 각 번호가
'선택되었는지를 저장할 수 있는' 리스트를 만들어야 한다.
다시 말해 1,000만 개 데이터를 저장할 수 있는 리스트를 만들어야 하므로
많은 메모리 공간이 낭비된다. 이중 999만개 가량의 데이터는 쓸모가 없다.
하지만 사전 자료형을 이용하는 경우 1,000만개의 데이터를 담을 필요가 없으며 10,000개의 데이터만 사전 자료구조에 들어가므로 훨씬 적은 메모리 공간을 사용할 수 있다.
사전 자료형에 특정한 원소가 있는지 검사할 때는 '원소 in 사전'의 형태를 사용할 수 있다. 이는 리스트나 튜플에 대해서도 사용할 수 있는 문법이다.
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

if'사과'in data:
print("'사과'를 키로 가지는 데이터가 존재합니다.")
출력문 --> '사과'를 키로 가지는 데이터가 존재합니다.

사전 자료형 관련 함수
또한 사전 자료형을 잘 이용하기 위해서는 이와 관련한 다양한 함수에 대해서 알야아 한다. 대표적으로는 키와 값을 별도로 뽑아내기 위한 함수가 있는데, 키 데이터만 뽑아서 리스트로 이용할 때는 keys() 함수를 이용하며
데이터를 뽑아서 이용할 때는 values()함수를 이용한다.
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'
key_list = data.keys()
value_list = data.values()
print(key_list) --> dict_keys(['사과','바나나','코코넛'])
print(value_list) -->dict_values(['Apple','Banana','Coconut'])

for key in key_list:
print(data[key]) --> Apple Banana Coconut이 순서대로 출력됨


#### 집합 자료형

파이썬에서는 집합을 처리하기 위한 집합 자료형을 제공한다.
집합은 기본적으로 리스트 혹은 문자열을 이용해서 만들 수 있는데,
집합은 다음과 같은 특징이 있다
- 중복을 허용하지 않는다.
- 순서가 없다.

리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있었다. 반면에 사전 자료형과 집합 자료형은 순서가 없다.
더불어 집합 자료형은 키가 존재하지 않고 값 데이터만을 담는다.
특정 원소가 존재하는지 검사하는 연산의 시간 복잡도는 O(1)이다.
방금 사전 자료형에 대해서 다룰 때 언급했던 '학생 번호가 주어졌을 때 해당 학생이 선택되었는지 여부를 출력하는 문제' 에서도 집합 자료형이 효과적으로 사용될 수 있다.
특히'특정한 데이터가 이미 등장한 적이 있는지 여부'를 체크할 때 매우 효과적이다.
집합 자료형을 초기화할 때는 set()함수를 이용하거나,
괄호({})안에 각 원소를 콤마(,)를 기준으로 구분해서 넣으면 된다.
data = set([1,1,2,3,4,4,5])
print(data) -->{1,2,3,4,5}
data = {1,1,2,3,4,4,5}
print(data) -->{1,2,3,4,5}

기본적인 집합 연산으로는 합집합, 교집합, 차집합 연산이 있다.
집합 자료형 데이터 사이에서 합집합을 계산할때는 '|'를 이용한다.
교집합은'&' 차집합은'-'을 이용한다.
a = set([1,2,3,4,5])
b = set([3,4,5,6,7])

print(a|b) -->{1,2,3,4,5,6,7} 합집합
print(a&b) -->{3,4,5} 교집합
print(a-b) -->{1,2} 차집합

**집합 자료형 관련 함수**

하나의 집합 데이터에 값을 추가할 때는 add() 함수를 이용할 수 있다.
update()함수는 여러 개의 값을 한꺼번에 추가하고자 할 때 사용한다.
특정한 값을 제거할 때는 remove() 함수를 이용할 수 있다.
이때 add(),remove()함수는 모두 시간 복잡도가 O(1)이다.

data = set([1,2,3])
print(data) --->{1,2,3}

data.add(4)
print(data) ---> {1,2,3,4}

data.update([5,6])
print(data) ---> {1,2,3,4,5,6}

data.remove(3)
print(data) --->{1,2,4,5,6}

_ _ _


## 조건문

프로그램을 작성할 때 프로그램의 흐름을 제어하는 문법이다.

예를 들어 어떤 변수의 값이 10 이상일 때에 한에서만
변수의 값을 출력하는 예시를 보자.
x = 15
if x>=10:
print(x)   --->15

파이썬에서 조건문을 작성할때는 if- elif ~else문을 이용한다.
if 조건문 1:
조건문 1이 트루일 경우 실행되는 코드
elif 조건문 2:
조건문 1에 해당하지 않고 2에 해당하는 경우 실행되는 코드
else:
위의 모든 조건문이 해당하지 않을 경우 실행되는 코드

성적 구간에 따른 학점 정보를 출력한다고 가정할때 조건문이 가장 쉽다.
성적이 90점 이상일 때 :A
성적이 90점 미만 80정 이상일때 :B
성적이 80점 미만 70점 이상일때 :C
성적이 70점 미만일 때:F

Score = 85

if score >= 90:
    print("학점 : A")
elif score >= 80:
    print("학점 : B")
elif score >= 70:
    print("학점 : C")
else
    print("학점: F")
조건문을 작성할 때는 코드의 블록을 들여쓰기로 설정한다.
(아직 미숙해서 코드작성을 제대로 블로그에 올리질 못한다.)

파이썬에서는 이왕이면 스페이스바 4번으로 들여쓰기 하는걸 추천한다.
(맨날 탭을 사용했는데 습관을 들여야 겠다;;)

####비교 연산자

조건문에는 비교 연산자를 자주 사용한다.
비교 연산은 특정한 두 값을 비교할 때 이용할 수 있다.
X==Y  --> X와 Y가 서로 같을 때 참이다.
X!=Y  --> X와 Y가 서로 다를 때 참이다.
X>Y
X<Y
X>=Y
x<=Y
나머지는 정리를 안해도 알 수 있으므로 패스.

####논리 연산자

논리 연산자는 2개의 논리 값 사이의 연산을 수행할 때 사용한다.
파이썬에는 3가지 논리 연산자가 있다.
X and Y // X or Y // not X
다 영어 그대로니 이해하긴 쉽다.

#####파이썬의 기타 연산자

파이썬에는 추가적으로 in연산자와 not in 연산자 를 제공한다.
여러 개의 데이터를 담는 자료형으로 리스트, 튜플, 문자열, 사전과 같은 자료형이 존재하는데, 여러개의 데이터를 담고 있기 때문에 자료형 안에 어떠한 값이 존재하는지 확인하는 연산이 필요할 때가 있다.
X in 리스트 --> 리스트 안에 X가 들어가 있을 때 참이다.
X not in 리스트 --> 문자열 안에 X가 들어가 있지 않을 때 참이다.

또한 파이썬에서는 조건문의 값이 참이라고 해도
아무것도 처리하고 싶지 않을 때 pass문을 이용할 수 있다.
score = 85

if score >= 80:
pass
else:
print('성적이 80점 미만입니다')
print('프로그램을 종료합니다.')

그리고 조건문에서 실행될 소스코드가 한 줄인 경우, 굳이 줄 바꿈을 하지 않고도 간략하게 표현할 수 있다. 예시는 다음과 같다.

score = 85

if score >= 80 : result = "Success"
else: result = "fail"

더 나아가서 조건부 표현식을 이용하면 if~else문을 한 줄에 작성해 사용할 수 있다.

score = 85
result= "success" if score >= 80 else "fail"

print(result)

특히 조건부 표현식은 리스트에 있는 원소의 값을 변경해서,
또 다른 리스트를 만들고자 할 때 매우 간결하게 사용할 수 있다.
예를 들어 리스트에서 특정한 원소의 값만을 없앤다고 해보자.
원래 일반적인 형태의 조건문은 다음과 같다.
a = [1,2,3,4,5,5,5]
remove_set = {3,5}

result = []
for i in a:
if i not in remove_set:
result.append(i)

print(result) --> 출력값 {1,2,4}

이 코드는 다음과 같이 간단하게 작성할 수 있다.
a = [1,2,3,4,5,5,5]
remove_set = {3,5}

result = [i for i in a if i not in remove_set]
print(result) --> 결과값은 동일하다.

_ _ _
### 반복문

반복문은 특정한 소스코드를 반복하고자 할때 쓰인다.
파이썬에서는 while문과 for문이 있는데 
코딩테스트에선 for문이 더 소스코드가 짧아서 자주 쓰인다.


**While문**
while문은 조건문이 참일때 한해서 반복적으로 수행된다.
이는 자바나 c랑 비슷하니 빠르게 예시하나만 작성하고 넘긴다.

i = 1
result = 0

while i<= 9:
result +=i
i += 1

print(result) --> 45

하나 더 만들어보자 
1부터 9까지의 수 중에서 홀수만 더하고자 할 때

i = 1
result = 0

while i <= 9:
if i%2 ==1:
result +=i
i+=1

print(result) --> 25

**for문**

반복문으로 for문을 이용할 수도 있다.
리스트를 사용하는 for문의 대표적인 구조는 다음과 같다.

for 변수 in 리스트 :
실행할 소스코드

앞의 예제와 동일하게 for문으로 구현해보자.

result = 0

for i in range(1,10):
result+=i

print(result) --> 45

여기서 range함수는 range(시작값, 끝값 +1)로 쓰면 된다.
수를 차례대로 나열할 때 쓰인다.

또한 range() 값으로 하나의 값만 넣으면 자동으로 시작값은 0이다.
예시로 학생의 번호를 1번부터 매긴다고 했을 때,
다음과 같이 학생마다 합격 여부를 출력할 수 있다.

scores = [90,85,77,65,97]

for i in rage(5):
if scores[i] >= 80:
print(i + 1, "번 학생은 합격입니다.")
출력값 --> 1번 학생은 합격입니다. 2번 학생은... 5번학생은,,,

반복문 안에서 continue를 만나면 프로그램의 흐름은
반복문의 처음으로 돌아간다.
위의 예제에서 2번 학생과 4번 학생은
블랙리스트에 올라가 있어서 점수가 높아도 합격하지 못한다고
가정해보자.
scores = [90,85,77,65,97]
cheating_list={2,4}

for i in range(5):
if i + 1 in cheating_list:
continue
if scores[i] >= 80:
print(i+1, "번 학생은 합격입니다.")
출력값 --> 1번 학생은 합격입니다. 5번 학생은 합격입니다.

더불어 반복문은 얼마든지 중첩이 가능하다.
코딩테스트에서도 "플로이드 워셜 알고리즘", "다이나믹 프로그래밍"
등의 알고리즘 문제에서 매우 많이 사용된다.

간단한 예시 2단부터 9단까지 출력하는 소스코드 예시를 보자.
for i in range(2,10):
for j in range(1,10):
print(i,"X",j,"=",i*j)
print()
실행결과는 생략
_ _ _
###함수

함수는 프로그래밍에서 굉장히 중요하다.
