### 파이썬 기본문법 총 정리 with(코딩테스트)
코딩테스트를 알아보면서, 자바로 코테를 준비하기에는 오랜 시간이
걸린다는 것을 깨달았다.

물론, 나중에 자바로도 준비를 해야겠지만 급한건 우선 취업을 위해 코테를 통과해야하므로... 그리고 요즘 파이썬이 대세이기도 하다.

기본 문법은 다른 언어들과 크게 다르지 않으니 하루만에 완독하고 습득한후
코테를 준비해보자!

_ _ _

정수형 데이터.
보통 코딩테스트에 나오는 숫자들은 정수형이다.
EX) a = 100 , print(a) --> 100 출력

실수형 데이터.
EX) a = 157.93 , print(a) --> 157.93

실수형 데이터를 표현하는 방식으로, 파이썬에서는 e나 E를 사용한다.
예를들어 1e9라고 입력하게 되면, 10의 9제곱이 된다.
-> 유효숫자e^지수 = 유효숫자x10^지수

지수 표현 방식은 코테에서 많이 사용된다.
예를 들어 최단 경로 문제에서는 도달할 수 없는 노드에 대하여 최단 거리를 '무한(INF)'으로 설정하곤 한다.
최단 경로로 가능한 최댓값이 10억 미만이라면 무한(INF)을 표현할때
10억을 이용할 수 있다. 이때 일일이 10억을 특정 변수에 대입하는 것은 번거롭기 때문에 1e9로 표현한다.
EX) a = 1e9 , print(a) --> 100000000.0 출력(10억)
a = 75.25e1 , print(a) --> 752.5
a = 3954e-3 , print(a) --> 3.954

보통 컴퓨터는 이진수로 데이터를 처리한다.
따라서 0.3 + 0.6은 0.9가 아니라 0.8999999로 출력된다.
a = 0.3 + 0.6

if a == 0.9:
print(True)
else:
print(False)
출력값 --> 0.8999999999999 Flase

소수점 값을 비교하는 작업이 필요한 문제라면 실수 값을 비교하지 못한다.
원하는결과를 얻기가 힘들다. 이럴때는 round() 함수를 이용한다.

- round()함수
이 함수를 호출할 때는 인자를 넣는데 첫 번째 인자는 실수형 데이터,
두 번째 인자는 [반올림하고자 하는 위치 -1] 이다.
예를 들어 123.456을 소수점 셋째 자리에서 반올림하려면
round(123.456,2) 라고 작성하며 결과는 123.46이다.


- 수 자료형의 연산
프로그래밍에서는 사칙연산을 이용해 계사ㅣㄴ한다.
이 중에서 나누기 연산자를 주의한다.
파이썬에서는 나누기 연산자를 기본적으로 실수형으로 처리한다.
코딩 테스트를 풀이할 때에는 나머지 연산자(%)를 이용해야 할 때가 많은데
예를 들어 특정한 변수 a 가 홀수인지 알아볼 때에는 'a를 2로 나눈 나머지가 1인지' 확인한다.
몫만을 얻고자 할때는 몫 연산자(//)를 이용한다.
EX) a=7 b=3
print(a/b) --> 2.33333333335
print(a%b) --> 1
print(a//b)--> 2

이외에도 거듭제곱 연산자를 비롯해 다양한 연산자들이 존재한다.
거듭제곱 연산자는 x**y형식으로 사용되는데, 이는 x^y를 의미한다.

EX) a = 5, b = 3 print(a**b) --> 5^3인 125 출력


_ _ _

####리스트 자료형

리스트는 자바나 C의 배열이라고 생각하면 될듯 하다.
내부적으로 연결 리스트 자료구조를 택하고 있어서 append(), remove()
등의 메서드를 지원한다.
리스트 대신에 배열 혹인 테이블아리고 부르기도 한다.

리스트는 대괄후([]) 안에 원소를 넣어 초기화하며, 쉼표(,)로 구분한다.
원소에 접근할 때는 인덱스 값을 괄호 안에 넣는다.
(인덱스는 0부터 시작한다.)
비어 있는 리스트를 선언하고자 할 때는 list()혹은 간단히 대괄호([])
를 이용할 수 있다.
EX) a =[1,2,3,4,5,6,7,8,9]
print(a) -->[1,2,3,4,5,6,7,8,9]출력
print(a[4]) --> 5 (0부터 시작하므로 5번째에 있는 5 출력)
a = list() ,print(a) -->[] (빈 리스트 선언 방법)
a = [] , print(a) -->[] (빈 리스트 선언 방법 2)

코딩 테스트 문제에서는 주로 크기가 N인 1차원 리스트를 초기화 해야 한다.
크기가 N이고 모든 값이 0인 1차원 리스트를 초기화 하는 소스 코드는 다음과 같다.
n = 10
a = [0]*n
print(a) 
출력값 : [0,0,0,0,0,0,0,0,0,0]

####리스트의 인덱싱과 슬라이싱
인덱스 값을 입력하여 특정한 리스트의 특정한 원소에 접근하는 것을 인덱싱이라고 한다.
파이썬의 인덱스 값은 양의 정수와 음의 정수 모두 사용할 수 있으며
음의 정수를 넣으면 원소를 거꾸로 탐색하게 된다.

예를 들어 인덱스에 -1을 넣으면 마지막 원소가 출력된다.
예시를 보자
EX) a = [1,2,3,4,5,6,7,8,9]
print(a[-1]) --> 9 
print(a[-3]) --> 7
a[3] = 7, print(a) --> [1.2.3.7.5.6.7.8.9] (네 번째 원소 변경)

연속적인 위치를 갖는 원소들을 가져와야 할 때는 슬라이싱을 할 수있다.
대괄호 안에 클론을 넣어서 시작 인덱스와 [끝 인덱스 - 1] 을 설정할 수 있다.
예시를 보자
EX) a = [1,2,3,4,5,6,7,8,9]
print(a[1:4]) --> [2,3,4] 출력 (4를 작성했으므로 3번째까지 출력)

#### 리스트 컴프리헨션

리스트 컴프리헨션은 리스트를 초기화하는 방법 중 하나이다.
대괄호([]) 안에 조건문과 반복문을 넣는 방식으로
리스트를 초기화할 수 있다.
EX) array = [i for i in range(20) if i % 2 == 1]

print(array) -->[1,3,5,7,9,11,13,15,17,19]
0부터 10까지의 수 중에서 홀수만 포함하는 리스트를 만들었다.

참고로 위 소스코드를 일반적인 소스코드로 작성하면 다음과 같다.
array = []
for i in range(20):
if i % 2 == 1:
array.append(i)

print(array)

또 다른 예시로 1부터 9까지 수의 제곱 값을 포함하는 리스트를
만들고자 할 때는 다음과 같이 리스트를 초기화 할 수 있다.
array = [i*i for i in range(1,10)]
print(array) --> [1,4,9,16,25,36,49,64,81]

이러한 리스트 컴프리헨션은 코딩 테스트에서 2차원 리스트를 초기화할 때
매우 효과적으로 사용될 수 있다.
예를 들어 N곱하기M 크기의 2차원 리스트를 초기화할때 다음과 같다.
n=3
m=4
array = [[0]  m for _ in range(n)]
print(array)
출력값 --> [[0,0,0,0],[0,0,0,0],[0,0,0,0]]

여기서 언더바는 변수의 값을 무시할 때 사용한다
예를 들어 단순히 Hello World를 5번 출력할 때는
for _ in range(5):
print("Hello World") 로 하면된다.

참고로 특정 크기의 2차원 리스트를 초기화할 때는 반드시
리스트 컴프리헨션을 이용해야 한다.
n=3
m=4
array =[[0] ******* m] ***** n
print(array)
출력값 --> [[0,0,0,0],[0,0,0,0],[0,0,0,0]]
array[1][1] = 5
print(array)
출력값 -> [[0,5,0,0],[0,5,0,0],[0,5,0,0]]

이처럼 3개의 리스트에서 인덱스 1에 해당하는 원소들의 값이
모두 5로 바뀐 것을 확인할 수 있다.
이는 내부적으로 포함된 3개의 리스트가 모두 동일한 객체에 대한
3개의 레퍼런스로 인식되기 때문이다.
따라서 특정한 크기를 가지는 2차원 리스트를 초기화할 때에는
리스트 컴프리헨션을 이용해야한다는 점을 기억해야 한다.

#####리스트 관련 기타 메서드

**append() --> 변수명.append()** 
// 리스트에 원소를 하나 삽입할 때 사용한다.
**sort() --> 변수명.sort()**
//기본 정렬 기능으로 오름차순으로 정렬한다.
(변수명.sort(reverse=True)내림차순)
**reverse() --> 변수명.reverse()**
//리스트의 원소의 순서를 모두 뒤집어 놓는다.
**insert() --> 변수명.insert(삽입할 위치 인덱스, 삽입할 값)**
//특정한 인덱스 위치에 원소를 삽입한다.
**count() --> 변수명.count(특정 값)**
//리스트에서 특정한 값을 가지는 데이터의 개수를 셀 때 사용
**remove() --> 변수명.remove(특정 값)**
//특정한 값을 갖는 원소를 제고하는데, 값을 가진 원소가 여러 개면
하나만 제거한다.

EX)
a = [1,4,3]
print("기본리스트: ", a) --> 기본리스트 : [1,4,3]

a.append(2)
prunt("삽입 : ", a) --> 삽입 : [1,4,3,2]

a.sort()
print("오름차순 정렬: " , a)  --> 오름차순 정렬 : [1,2,3,4]

a.sort(reverse = True)
print("내림차순 정렬: ",a) --> 내림차순 정렬 : [4,3,2,1]

a.reverse()
print("원소 뒤집기: ", a) --> 원소 뒤집기 : [1,2,3,4]

a.insert(2,3)
print("인덱스 2에 3 추가:" a) --> [1,2,3,3,4]

print("값이 3인 데이터 개수: " ,a.count(3)) -->2

a.remove(1)
print("값이 1인 데이터 삭제:",a)  --> [2,3,3,4]

**이 중에서 insert() 함수와 append(),remove()를 눈여겨두자**

코딩 테스트에서 insert() 함수를 사용할 때 원소의 개수가 N개면
시간 복잡도는 O(N)이다. 파이썬의 리스트 자료형의 append() 함수는
O(1)에 수행되는데 반해 insert() 함수는 동작이 느리다.
중간에 원소를 삽입한 뒤에, 리스트의 원소 위치를 조정해줘야 하기 때문이다.
따라서 insert() 함수를 남발하면 '시간 초과'로 테스트를 통과하지 못할 수도 있다.

remove의 시간 복잡도는 insert()함수와 마찬가지로 O(N)이다.

**특정한 값의 원소를 모두 제거하려면 어떻게 해야할까?**
(remove를 남발하면 안되는 이유는 위에서 배웠다.)

a = [1,2,3,4,5,5,5]
remove_set = {3,5}

result = [i for i in a if i not in remove_set]
print(result)
출력 값 --> [1,2,4]

다음 코드에서 result 부분은 a에 포함된 원소를 하나씩 확인하며
그 원소가 remove_set에 포함되어 있지 않았을 때만
리스트 변수인 result에 넣겠다는 의미이다.

_ _ _
#### 문자열 자료형

**문자열 초기화**

문자열 변수를 초기화할 때는 큰따옴표(")나 작은따옴표(')를 사용한다.
큰 따옴표나 작은 따옴표는 백슬래시(\)를 사용하면 문자열에 포함시킬 수 있다.
(기본적으로 큰따옴표로 구성하면 작은 따옴표 사용가능 반대도 가능!)

data = 'Hello World'
print(data) --> Hellow world

data = "Don't you know \"Python\"?"
print(data) --> Don't you know \"Python\"?'

**문자열 연산**
파이썬은 문자열에 대한 연산도 지원하는데 문자열을 처리할 때 유용하게 사용할 수 있다.
예를들어 문자열 변수에 덧셈을 이용하면 문자열이 더해진다 (단순하다.)

a = "Hello"
b = "World"

print(a + " " + b) --> Hello World

문자열 변수를 양의 정수와 곱하는 경우, 문자열이 그 값만큼 여러 번 더해진다.

a = "String"
print(a*3) --> StringStringString

파이썬의 문자열은 내부적으로 리스트와 같이 처리된다.
따라서 문자열도 인덱싱과 슬라이싱을 할 수 있다.

a = "ABCDEF"

print(a[2:4]) --> CD

**튜플 자료형**

파이썬의 튜플 자료형은 리스트와 거의 비슷한데 다음과 같은 차이가 있다.

 - 튜플은 한번 선언된 값을 변경할 수 없다.
 - 리스트는 대괄호를 이용하지만, 튜플은 소괄호를 이용한다.

튜플의 예시를 보자.
a = (1,2,3,4)
print(a)
a[2] = 7
출력값 --> (1,2,3,4)
Traceback (most recent call last):
File "main.py", line4, in<module>
a[2] = 7
TypeError: 'tuple' object does not supprot item assignment
위는 에러가 났다는 뜻이다.

튜플의 값(1,2,3,4)는 그대로 출력된다.
하지만 특정한 값을 변경하려고 하면 오류가 발생된다.
튜플 자료형은 그래프 알고리즘을 구현할 때 자주 사용된다.
예를 들어 다익스트라 최단 경로 알고리즘처럼
최단 경로를 찾아주는 알고리즘의 내부에서는 우선순위 큐를 이용하는데
해당 알고리즘에서 우선순위 큐에 한 번 들어간 값은 변경되지 않는다.
그래서 우선순위 큐에 들어가는 데이터를 튜플로 구성하여 소스코드를 작성한다.
또한 튜플은 리스트에 비해 상대적으로 공간 효율적이고,
일반적으로 각 원소의 성질이 서로 다를 때 주로 사용한다.
흔히 다익스트라 최단 경로 알고리즘에서는 '비용'과 '노드 번호'라는
서로 다른 성질의 데이터를 (비용, 노드 번호)의 형태로 함께 튜플로
묶어서 관리하는 것이 관례이다.

(사실 지금 이 글을 잘 모르겠지만 알고리즘 공부하면 알게되겠지..)

#### 사전 자료형

사전 자료형은 키와 값의 쌍을 데이터로 가지는 자료형이다.
예를 들어 다음과 같이 키-값 쌍으로 구성되는 데이터를
담아야 한다면 어떻게 할 수 있을까?
키 값
사과 - Apple
바나나 - Banana
코코넛 - Coconut
키로 한글 단어를 넣고, 값으로 영어 단어를 넣어 '사과'의 영어 단어를 알고 싶다면 '사과'라는 키 값을 가지는 데이터에 바로 접근하면 된다.
파이썬의 사전 자료형은 내부적으로 '해시 테이블'을 이용하므로
기본적으로 데이터의 검색 및 수정에 있어서 O(1)의 시간에 처리할 수 있다.

EX)
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

print(data) --> {'사과': 'Aplle', '바나나':'Banana', '코코넛':'Coconut'}
이러한 사전 자료형은 코딩 테스트에서도 자주 사용될 수 있다.
예를 들어 번호가 1부터 10,000,000까지로 구성되어 있는 상황에서
최대 10,000명의 학생을 선택했다고 가정하자.
이후에 특정한 학생 번호가 주어졌을 때 해당 학생이 선택되었는지를
어떻게 빠르게 알 수 있을까?
만약 리스트를 이용한다면, 1부터 10,000,000까지의 각 번호가
'선택되었는지를 저장할 수 있는' 리스트를 만들어야 한다.
다시 말해 1,000만 개 데이터를 저장할 수 있는 리스트를 만들어야 하므로
많은 메모리 공간이 낭비된다. 이중 999만개 가량의 데이터는 쓸모가 없다.
하지만 사전 자료형을 이용하는 경우 1,000만개의 데이터를 담을 필요가 없으며 10,000개의 데이터만 사전 자료구조에 들어가므로 훨씬 적은 메모리 공간을 사용할 수 있다.
사전 자료형에 특정한 원소가 있는지 검사할 때는 '원소 in 사전'의 형태를 사용할 수 있다. 이는 리스트나 튜플에 대해서도 사용할 수 있는 문법이다.
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'

if'사과'in data:
print("'사과'를 키로 가지는 데이터가 존재합니다.")
출력문 --> '사과'를 키로 가지는 데이터가 존재합니다.

사전 자료형 관련 함수
또한 사전 자료형을 잘 이용하기 위해서는 이와 관련한 다양한 함수에 대해서 알야아 한다. 대표적으로는 키와 값을 별도로 뽑아내기 위한 함수가 있는데, 키 데이터만 뽑아서 리스트로 이용할 때는 keys() 함수를 이용하며
데이터를 뽑아서 이용할 때는 values()함수를 이용한다.
data = dict()
data['사과'] = 'Apple'
data['바나나'] = 'Banana'
data['코코넛'] = 'Coconut'
key_list = data.keys()
value_list = data.values()
print(key_list) --> dict_keys(['사과','바나나','코코넛'])
print(value_list) -->dict_values(['Apple','Banana','Coconut'])

for key in key_list:
print(data[key]) --> Apple Banana Coconut이 순서대로 출력됨


#### 집합 자료형

파이썬에서는 집합을 처리하기 위한 집합 자료형을 제공한다.
집합은 기본적으로 리스트 혹은 문자열을 이용해서 만들 수 있는데,
집합은 다음과 같은 특징이 있다
- 중복을 허용하지 않는다.
- 순서가 없다.

리스트나 튜플은 순서가 있기 때문에 인덱싱을 통해 자료형의 값을 얻을 수 있었다. 반면에 사전 자료형과 집합 자료형은 순서가 없다.
더불어 집합 자료형은 키가 존재하지 않고 값 데이터만을 담는다.
특정 원소가 존재하는지 검사하는 연산의 시간 복잡도는 O(1)이다.
방금 사전 자료형에 대해서 다룰 때 언급했던 '학생 번호가 주어졌을 때 해당 학생이 선택되었는지 여부를 출력하는 문제' 에서도 집합 자료형이 효과적으로 사용될 수 있다.
특히'특정한 데이터가 이미 등장한 적이 있는지 여부'를 체크할 때 매우 효과적이다.
집합 자료형을 초기화할 때는 set()함수를 이용하거나,
괄호({})안에 각 원소를 콤마(,)를 기준으로 구분해서 넣으면 된다.
data = set([1,1,2,3,4,4,5])
print(data) -->{1,2,3,4,5}
data = {1,1,2,3,4,4,5}
print(data) -->{1,2,3,4,5}

기본적인 집합 연산으로는 합집합, 교집합, 차집합 연산이 있다.
집합 자료형 데이터 사이에서 합집합을 계산할때는 '|'를 이용한다.
교집합은'&' 차집합은'-'을 이용한다.
a = set([1,2,3,4,5])
b = set([3,4,5,6,7])

print(a|b) -->{1,2,3,4,5,6,7} 합집합
print(a&b) -->{3,4,5} 교집합
print(a-b) -->{1,2} 차집합

**집합 자료형 관련 함수**

하나의 집합 데이터에 값을 추가할 때는 add() 함수를 이용할 수 있다.
update()함수는 여러 개의 값을 한꺼번에 추가하고자 할 때 사용한다.
특정한 값을 제거할 때는 remove() 함수를 이용할 수 있다.
이때 add(),remove()함수는 모두 시간 복잡도가 O(1)이다.

data = set([1,2,3])
print(data) --->{1,2,3}

data.add(4)
print(data) ---> {1,2,3,4}

data.update([5,6])
print(data) ---> {1,2,3,4,5,6}

data.remove(3)
print(data) --->{1,2,4,5,6}

_ _ _


## 조건문

프로그램을 작성할 때 프로그램의 흐름을 제어하는 문법이다.

예를 들어 어떤 변수의 값이 10 이상일 때에 한에서만
변수의 값을 출력하는 예시를 보자.
x = 15
if x>=10:
print(x)   --->15

파이썬에서 조건문을 작성할때는 if- elif ~else문을 이용한다.
if 조건문 1:
조건문 1이 트루일 경우 실행되는 코드
elif 조건문 2:
조건문 1에 해당하지 않고 2에 해당하는 경우 실행되는 코드
else:
위의 모든 조건문이 해당하지 않을 경우 실행되는 코드

성적 구간에 따른 학점 정보를 출력한다고 가정할때 조건문이 가장 쉽다.
성적이 90점 이상일 때 :A
성적이 90점 미만 80정 이상일때 :B
성적이 80점 미만 70점 이상일때 :C
성적이 70점 미만일 때:F

Score = 85

if score >= 90:
    print("학점 : A")
elif score >= 80:
    print("학점 : B")
elif score >= 70:
    print("학점 : C")
else
    print("학점: F")
조건문을 작성할 때는 코드의 블록을 들여쓰기로 설정한다.
(아직 미숙해서 코드작성을 제대로 블로그에 올리질 못한다.)

파이썬에서는 이왕이면 스페이스바 4번으로 들여쓰기 하는걸 추천한다.
(맨날 탭을 사용했는데 습관을 들여야 겠다;;)

####비교 연산자

조건문에는 비교 연산자를 자주 사용한다.
비교 연산은 특정한 두 값을 비교할 때 이용할 수 있다.
X==Y  --> X와 Y가 서로 같을 때 참이다.
X!=Y  --> X와 Y가 서로 다를 때 참이다.
X>Y
X<Y
X>=Y
x<=Y
나머지는 정리를 안해도 알 수 있으므로 패스.

####논리 연산자

논리 연산자는 2개의 논리 값 사이의 연산을 수행할 때 사용한다.
파이썬에는 3가지 논리 연산자가 있다.
X and Y // X or Y // not X
다 영어 그대로니 이해하긴 쉽다.

#####파이썬의 기타 연산자

파이썬에는 추가적으로 in연산자와 not in 연산자 를 제공한다.
여러 개의 데이터를 담는 자료형으로 리스트, 튜플, 문자열, 사전과 같은 자료형이 존재하는데, 여러개의 데이터를 담고 있기 때문에 자료형 안에 어떠한 값이 존재하는지 확인하는 연산이 필요할 때가 있다.
X in 리스트 --> 리스트 안에 X가 들어가 있을 때 참이다.
X not in 리스트 --> 문자열 안에 X가 들어가 있지 않을 때 참이다.

또한 파이썬에서는 조건문의 값이 참이라고 해도
아무것도 처리하고 싶지 않을 때 pass문을 이용할 수 있다.
score = 85

if score >= 80:
pass
else:
print('성적이 80점 미만입니다')
print('프로그램을 종료합니다.')

그리고 조건문에서 실행될 소스코드가 한 줄인 경우, 굳이 줄 바꿈을 하지 않고도 간략하게 표현할 수 있다. 예시는 다음과 같다.

score = 85

if score >= 80 : result = "Success"
else: result = "fail"

더 나아가서 조건부 표현식을 이용하면 if~else문을 한 줄에 작성해 사용할 수 있다.

score = 85
result= "success" if score >= 80 else "fail"

print(result)

특히 조건부 표현식은 리스트에 있는 원소의 값을 변경해서,
또 다른 리스트를 만들고자 할 때 매우 간결하게 사용할 수 있다.
예를 들어 리스트에서 특정한 원소의 값만을 없앤다고 해보자.
원래 일반적인 형태의 조건문은 다음과 같다.
a = [1,2,3,4,5,5,5]
remove_set = {3,5}

result = []
for i in a:
if i not in remove_set:
result.append(i)

print(result) --> 출력값 {1,2,4}

이 코드는 다음과 같이 간단하게 작성할 수 있다.
a = [1,2,3,4,5,5,5]
remove_set = {3,5}

result = [i for i in a if i not in remove_set]
print(result) --> 결과값은 동일하다.

_ _ _
### 반복문

반복문은 특정한 소스코드를 반복하고자 할때 쓰인다.
파이썬에서는 while문과 for문이 있는데 
코딩테스트에선 for문이 더 소스코드가 짧아서 자주 쓰인다.


**While문**
while문은 조건문이 참일때 한해서 반복적으로 수행된다.
이는 자바나 c랑 비슷하니 빠르게 예시하나만 작성하고 넘긴다.

i = 1
result = 0

while i<= 9:
result +=i
i += 1

print(result) --> 45

하나 더 만들어보자 
1부터 9까지의 수 중에서 홀수만 더하고자 할 때

i = 1
result = 0

while i <= 9:
if i%2 ==1:
result +=i
i+=1

print(result) --> 25

**for문**

반복문으로 for문을 이용할 수도 있다.
리스트를 사용하는 for문의 대표적인 구조는 다음과 같다.

for 변수 in 리스트 :
실행할 소스코드

앞의 예제와 동일하게 for문으로 구현해보자.

result = 0

for i in range(1,10):
result+=i

print(result) --> 45

여기서 range함수는 range(시작값, 끝값 +1)로 쓰면 된다.
수를 차례대로 나열할 때 쓰인다.

또한 range() 값으로 하나의 값만 넣으면 자동으로 시작값은 0이다.
예시로 학생의 번호를 1번부터 매긴다고 했을 때,
다음과 같이 학생마다 합격 여부를 출력할 수 있다.

scores = [90,85,77,65,97]

for i in rage(5):
if scores[i] >= 80:
print(i + 1, "번 학생은 합격입니다.")
출력값 --> 1번 학생은 합격입니다. 2번 학생은... 5번학생은,,,

반복문 안에서 continue를 만나면 프로그램의 흐름은
반복문의 처음으로 돌아간다.
위의 예제에서 2번 학생과 4번 학생은
블랙리스트에 올라가 있어서 점수가 높아도 합격하지 못한다고
가정해보자.
scores = [90,85,77,65,97]
cheating_list={2,4}

for i in range(5):
if i + 1 in cheating_list:
continue
if scores[i] >= 80:
print(i+1, "번 학생은 합격입니다.")
출력값 --> 1번 학생은 합격입니다. 5번 학생은 합격입니다.

더불어 반복문은 얼마든지 중첩이 가능하다.
코딩테스트에서도 "플로이드 워셜 알고리즘", "다이나믹 프로그래밍"
등의 알고리즘 문제에서 매우 많이 사용된다.

간단한 예시 2단부터 9단까지 출력하는 소스코드 예시를 보자.
for i in range(2,10):
for j in range(1,10):
print(i,"X",j,"=",i*j)
print()
실행결과는 생략
_ _ _
###함수

함수는 프로그래밍에서 굉장히 중요하다.
프로그래밍을 하다보면 똑같은 코드가 반복적으로 사용될 때가 많다.
함수를 사용하지 않으면 소스코드를 일일이 작성해야 한다.
코딩 테스트에서도 테스트 케이스가 입력된 뒤에 테스트 케이스만큼
특정한 알고리즘을 수행한 결과를 반복적으로 출력하도록
요구하는 문제가 출제되는 경우가 많다.

파이썬에서 함수의 구조는 다음과 같다.
함수를 작성할 때는 함수 내부에서 사용되는 변수의 값을 전달받기 위해 매개변수를 정의할 수 있다.
이후에 함수에서 어떠한 값을 반환하고자 할 때는 return을 이용한다.
이때 함수에서 매개변수나 return문은 존재하지 않을 수도 있다.
```
def 함수명(매개변수):
	실행할 소스 코드
    return 반환 값
```

대표적인 함수의 예시인 더하기 기능을 제공하는 함수를 보자
```
def add(a, b):
	return a+b
    
print(add(3,7)) -->  10
```
앞서 언급했듯이, 동일한 함수를 return문 없이 작성할 수 있다.
```
def add(a, b):
    print('함수의 결과:', a+b)
    
add(3,7) --> 함수의 결과: 10
```

또한 함수를 호출하는 과정에서 다음과 같이 인자를 넘겨줄 때
파라미터의 변수를 직접 지정해서 값을 넣을 수 있다.
```
def add(a, b):
    print('함수의 결과:', a + b)
    
add(b = 3, a = 7) --->함수의 결과: 10
```
그리고 함수 안에서 함수 밖의 변수 데이터를 변경해야 하는 경우가 있다. 이때는 함수에서 global 키워드를 이용하면 된다.
global 키워드로 변수를 지정하면, 해당 함수에서는 지역 변수를 만들지 않고, 함수 바깥에 선언된 변수를 바로 참조하게 된다.

```
a = 0

def func():
	global a
    a += 1

for i in range(10):
	func()
    
print(a) --> 10
```

끝으로, 파이썬에서는 람다 표현식을 사용할 수 있다.
람다 표현식을 이용하면 함수를 매우 간단하게 작성하여 적용할 수 있다. 특정한 기능을 수행하는 함수를 한 줄에 작성할 수 있다는 점이 특징이다.
```
def add(a, b):
    return a + b
    
print(add(3,7)) --> 10

print((lambda a, b: a + b)(3,7)) --> 10
```
_ _ _

####입출력

알고리즘 문제 풀이의 첫 번째 단계는 데이터를 입력받는 것이다.
알고리즘 문제의 경우 적절한 입력이 주어졌을 때그 입력을 받아서 적절한 알고리즘을 수행한 뒤의 결과를 출력하는 것을 요구한다.

파이썬에서 데이터를 입력받을 때는 input()을 이용한다.
input()의 경우 한 줄의 문자열을 입력받도록 해준다.
만약 파이썬에서 입력받은 데이터를 정수형 데이터로 처리하기 위해서는 문자열을 정수로 바꾸는 int() 함수를 사용해야 한다.

그리고 여러 개의 데이터를 입력받을 때는 데이터가 공백으로 구분되는 경우가 많다. 그래서 입력받은 문자열을 띄어쓰기로 구분하여 각각 정수형의 데이터로 저장하는 코드의 사용 빈도가 매우 높다. 이때는 
list(map(int, input().split()))을 이용하면 된다.
동작과정은 다음과 같다.
먼저 input()으로 입력받은 문자열을 split()을 이용해 공백으로 나눈 리스트로 바꾼 뒤에, map을 이용하여 해당 리스트의 모든 원소에 int()함수를 적용한다.
최종적으로 그 결과를 list()로 다시 바꿈으로써 입력받은 문자열을 띄어쓰기로 구분하여 각각 숫자 자료형으로 저장하게 되는 것이다.

이 코드는 많이 사용되므로 반드시 외우자!

코딩테스트에서 입력을 위해 사용되는 전형적인 소스코드는 다음과 같다.
```
n = int(input())
data = list(map(int, input().split()))

data.sort(reverse = True)
print(data)
```
```
입력값 : 5 엔터 , 65 90 75 34 99 엔터
출력값 : [99,90,75,65,34]
```

공백으로 구분된 데이터의 개수가 많지 않다면, 단순히
map(int, input().split())을 이용하는 것도 가능하다.
```
n, m, k = map(int, input().split())

print(n, m, k)
```
```
입력 값 : 3 5 7
출력 값 : 3 5 7
```

또한 문제를 풀다보면, 입력을 최대한 빠르게 받아야 하는 경우가 있다.
흔히 정렬, 이진 탐색, 최단 경로 문제의 경우 매우 많은 수의 데이터가 
연속적으로 입력 되곤 한다.
파이썬의 기본 input() 함수는 동작 속도가 느려서 시간 초과로
오답 판정을 받을 수 있기 때문에 파이썬의 sys 라이브러리에
정의되어 있는 sys.stdin.readline() 함수를 이용한다.
sys 라이브러리는 다음과 같은 방식으로 사용하며 input() 함수와 같이 한 줄씩 입력받기 위해 사용한다.

```
import sys
sys.stdin.readline().rstrip()
```
sys 라이브러리를 사용할 때는 한 줄 입력을 받고 나서
rstrip() 함수를 꼭 호출해야 한다.
readline()으로 입력하면 입력 후 엔터가 줄 바꿈 기호로 입력되는데
이 공백 문자를 제거하려면 rstrip()함수를 사용해야 한다.
이 또한 짧은 코드이니 관행적으로 외워서 사용한다.
```
import sys

data = sys.stdin.readline().rstrip()
print(data) --> 입력 값 Hello World 출력값 Hello World
```

입력은 여기까지 하고 출력에 대해 알아보자

출력은 print()를 이용하여 하면 된다.
a = 1
b = 2
print(a, b) --> 1 2

print()는 각 변수를 콤마(,)로 구분하여 매개변수로 넣을 수 있다.
이 경우 각 변수가 띄어쓰기로 구분되어 출력된다.

또한 파이썬의 print()는 기본적으로 출력 이후에 줄 바꿈을 수행한다.
따라서 print()를 사용할때마다 줄이 변경된다고 보면 된다.
```
a = 1
b = 2

print(a)
print(b)
```
```
#출력값
1
2
```

일부 문제의 경우 출력할 때 문자열과 수를 함께 출력해야 되는 경우가 있다. 이 경우 단순히 더하기 연산자를 이용하여 문자열과 수를 더하면 오류가 발생한다.
```
answer = 7

print("정답은" + answer + "입니다. ") --> 에러
```
이럴땐 데이터를 문자열로 바꿔주거나 혹은 각 자료형을
콤마를 기준으로 구분하여 출력하면 된다.
ex) print("정답은" + str(answer)+"입니다.")
print("정답은",str(answer),"입니다.")
대신 각 변수를 콤마로 구분하여 출력하는 경우,
변수의 값 사이에 의도치 않은 공백이 삽입될 수 있다.
또한 파이썬 3.6 이상의 버전부터 f-string 문법을 사용할 수 있다.
f-string은 문자열 앞에 접두사 'f'를 붙임으로써 사용할 수 있는데
단순히 중괄호({})안에 변수를 넣음으로써, 자료형의
변환 없이도 바꾸지 않고 간단히 문자열과 정수를 함께 넣는다.
```
answer= 7
print(f"정답은 {answer} 입니다.") --> 정답은 7 입니다.
```


_ _ _

### 주요 라이브러리의 문법

**표준 라이브러리**
특정한 프로그래밍 언어에서 자주 사용되는 표준 소스코드를 미리 구현해 놓은 라이브러리를 의미한다.
- https://docs.python.org/ko/3/library/index.html

코딩 테스트를 준비하며 반드시 알아야 할 라이브러리는
6가지 정도이다.
이 6가지 라이브러리 또한 각각 많은 기능을 포함하고 있어서
모든 기능을 언급할 수는 없으므로, 여기서는 각 라이브러리의 가장 중요하고 알아두어야 할 핵심 내용만 요약한다.

- 내장 함수 : print(),input()과 같은 기본 입출력 기능부터 sorted()와 같은 정렬 기능을 포함하고 있는 기본 내장 라이브러리이다.
- itertools : 파이썬에서 반복되는 형태의 데이터를 처리하는 기능을 제공하는 라이브러리이다. 순열과 조합 라이브러리를 제공한다.
- heapq:힙(Heap) 기능을 제공하는 라이브러리이다. 우선순위 큐 기능을 구현하기 위해 사용한다.
- bisect: 이진 탐색 기능을 제공하는 라이브러리이다.
- collections:덱(deque),카운터(counter)등의 유용한 자료구조를 포함하고 있는 라이브러리이다.
- mate:필수적인 수학적 기능을 제공하는 라이브러리이다. 팩토리얼, 제곱근, 최대공약수, 삼각함수 관련 함수부터 파이같은 상수를 포함하고 있다.

** 내장함수 **

파이썬에서는 별도의 import 명령어 없이 바로 사용할 수 있는 내장 함수가 존재한다. 대표적인 내장 함수는 input(),print()이다. 이를 제외하고 알아보자.

먼저 sum()함수는 리스트와 같은 iterable 객체가 입력으로 주어졌을 때, 모든 원소의 합을 반환한다.
(파이썬에서 iterable 객체는 반복 가능한 객체를 말한다.)
(리스트, 사전 자료형, 튜플 자료형 등이 이에 해당한다.)
```
result = sum([1,2,3,4,5])
print(result) -->출력값 : 15
```
min() 함수는 파라미터가 2개 이상 들어왔을 때 가장 작은 값을 반환한다.
예를 들어 특정한 4개의 정수 중에서 가장 작은 수를 출력하는 예시를 확인해보자.
```
result = min(7,3,5,2)
print(result) -->출력값: 2
```
Max() 함수는 파라미터가 2개 이상 들어왔을 때 가장 큰 값을 반환한다.
마찬가지로 4개의 정수 중에서 가장 큰 수를 출력하는 예시를 확인해보자.
```
result = max(7, 3, 5, 2)
print(result) --->출력값 : 7
```

eval() 함수는 수학 수식이 문자열 형식으로 들어오면 해당 수식을 계산한 결과를 반환한다.
```
result = eval("(3+5)*7")
print(result) --> 출력값: 56
```

sorted() 함수는 iterable 객체가 들어왔을 때, 정렬된 결과를 반환한다.
key속성으로 정렬 기준을 명시할 수 있으며, reverse 속성으로 정렬된 결과 리스트를 뒤집을지의 여부를 설정할 수 있다.
```
result = sorted([9, 1, 8, 5, 4])
print(result) --> [1, 4, 5, 8, 9]
result = sorted([9, 1, 8, 5, 4], reverse = True)
print(result) --> [9, 8, 5, 4, 1]
```

파이썬에서는 리스트의 원소로 리스트나 튜플이 존재할 때 특정한 기준에 따라서 정렬을 수행할 수 있다. 정렬 기준은 key 속성을 이용해 명시할 수 있다. 
```
result = sorted([('홍길동',35),('이순신',75),('아무개',50)], key = lambda x: x[1], reverse = True)
print(result) --> 출력값 [('이순신',75),('아무개',50),('홍길동',35)]
```

리스트와 같은 iterable 객체는 기본으로 sort() 함수를 내장하고 있어서 굳이 sorted()함수를 사용하지 않고도 sort() 함수를 사용해서 정렬할 수 있다. 이 경우 리스트 객체의 내부 값이 정렬된 값으로 바로 변경된다.
```
data = [9,1,8,5,4]
data.sort()
print(data) --> [1,4,5,8,9]
```

**itertools**
파이썬에서 반복되는 데이터를 처리하는 기능을 포함하고 있는 라이브러리이다. 코딩테스트에서 가장 유용하게 사용할 수 있는 클래스는 permutations,combinations이다.
permutations는 리스트와 같은 iterable 객체에서 r개의 데이터를 뽑아 일렬로 나열하는 모든 경우(순열)을 계산해준다. permutations는 클래스이므로 객체 초기화 이후에는 리스트 자료형으로 변환하여 사용한다. 리스트['A','B','C']에서 3개를 뽑아 나열하는 모든 경우를 출력하는 예시는 다음과 같다.
```
from itertools improt permutations

data = ['A','B','C']
result = list(permutations(data, 3))

print(result)
```
```
[('A','B','C'),('A','C','B')...6개]

```

combinations는 리스트와 같은 iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우를 계산한다.
combinations는 클래스이므로 객체 초기화 이후에는 리스트 자료형으로 변환하여 사용한다.
```
from itertools import combinations

data = ['A','B','C']
result = list(combinations(data, 2))

print(result)
```
```
[('A','B'),('A','C'),('B','C')]
```

product는 permutations와 같이 리스트와 같은 iterable 객체에서
r개의 데이터를 뽑아 일렬로 나열하는 모든 순열을 계산한다
다만 원소를 중복하여 뽑닌다.
product 객체를 초기화 할 때는 뽑고자 하는 데이터의 수를 repeat 속성값으로 넣어준다.
```
from itertools import product

data = ['A','B','C']
result = list(product(data, repeat=2))

print(result)
```
```
[('A','A'),('A','B'),('A','C'),('B','A'),('B','B'),('B','C'),('C','A'),('C','B'),('C','C')]
```

combinatins_with_replacement는 combinations와 같이 리스트와 같은 iterable 객체에서 r개의 데이터를 뽑아 순서를 고려하지 않고 나열하는 모든 경우를 계산한다. 다만 원소를 중복해서 뽑는다.
```
from itertools import combinations_with_replacement

data = ['A','B','C']
result = list(combinations_with_replacement(data,2))
print(result)
```
```
[('A','A'),('A','B'),('A','C'),('B','B'),('B','C'),('C','C')]
```

**heapq**
파이썬에서는 힙 기능을 위해 heapq 라이브러리를 제공한다.
heapq는 다익스트라 최단 경로 알고리즘을 포함해 다양한 알고리즘에서 우선순위 큐 기능을 구현하고자 할 때 사용된다.
파이썬의 힙은 최소 힙으로 구성되어 있으므로 단순이 원소를 힙에 전부 넣었다가 빼는 것만으로도 시간 복잡도O(NlogN)에 오름차순 정렬이 완료된다. 보통 최소 힙 자료구조의 최상단 원소는 항상 '가장 작은' 원소이기 때문이다.
힙에 원소를 삽입할 때는 heapq.heappush() 메서드를 이용하고, 힙에서 원소를 꺼내고자 할 때는 heapq.heappop()메서드를 이용한다.
```
import heapq

def heapsort(iterable):
	h = []
    result = []
    
    for value in iterable:  #모든 원소를 차례대로 힙에 삽입
    	heapq.heappush(h,value)
        
   #힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
   for i in range(len(h)): 
    	result.append(heapq.heappop(h))
    return result
    
result = heapsort([1, 3, 5, 7, 8, 2, 4, 6, 8, 0])
print(result)
```
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

또한 파이썬에서는 최대 힙을 제공하지 않는다.
따라서 heapq 라이브러리를 이용하여 최대 힙을 구현해야 할 때는 원소의 부호를 임시로 변경하는 방식을 사용한다. 힙에 원소를 삽입하기 전에 잠시 부호를 반대로 바꾸었다가, 힙에서 원소를 꺼낸 뒤에 다시 원소의 부호를 바꾸면 된다.
```
import heapq

def heapsort(iterable):
	h = []
    result = []
    #모든 원소를 차례대로 힙에 삽입
    for value in iterable:
    	heapq.heappush(h, -value)
    #힙엡 삽입된 모든 원소를 차례대로 꺼내어 담기
    for i range(len(h)):
    	result.append(-heapq.heappop(h))
    return result

result = heapsort([1, 3, 5, 7, 9, 2, 4, 6, 8, 0])
print(result)
```
```
[9, 8, 7, 6, 5, 4, 3, 2, 1, 0]
```

** bisect **

파있너에서는 이진 탐색을 쉽게 구현할 수 있도록 bisect 라이브러리를 제공한다. bisect 라이브러리는 '정렬된 배열'에서 특정한 원소를 찾아야 할 때 매우 효과적으로 사용된다. bisect 라이브러리에서는 bisect_left()함수와 bisect_right() 함수가 가장 중요하게 사용되며, 이 두 함수는 시간 복잡도O(logN)에 동작한다.
- bisect_left(a, x): 정렬된 순서를 유지하면서 리스트 a에 데이터 x를 삽입할 가장 왼쪽 인덱스를 찾는 메서드
- bisect_right(a, x): 정렬된 순서를 유지하도록 리스트 a에 데이터 x를 삽입할 가장 오른쪽 인덱스를 찾는 메서드

예를 들어 정렬된 리스트[1, 2, 4, 4, 8]이 있을 때, 새롭게 데이터 4를 삽입하려 한다고 가정하자. 이때 bisect_left(a, 4)와 bisect_right(a, 4)는 각각 인덱스값으로 2와 4를 반환한다.
```
from bisect import bisect_left, bisect_right

a = [1, 2, 4, 4, 8]
x = 4

print(bisect_left(a, x))
print(bisect_right(a, x))
```
```
2
4
```

또한 bisect_left()함수와 bisect_right() 함수는 '정렬된 리스트'에서 '값이 특정 범위에 속하는 원소의 개수'를 구하고자 할 때, 효과적으로 사용될 수 있다.
아래의 count_by_range(a, left_value,right_value) 함수를 확인해보자. 이는 정렬된 리스트에서 값이 [left_value, right_value]에 속하는 데이터의 개수를 반환한다. 다시 말해 원소의 값을 x라고 할 때, left_value<=x<=right_value인 원소의 개수를 O(logN)으로 빠르게 계산할 수 있다.
```
from bisect import bisect_left, bisect_right

#값이 [left_value, right_value]인 데이터의 개수를 반환하는 함수
def count_by_range(a, left_value, right_value):
	right_index = bisect_right(a, right_value)
    left_index = bisect_left(a, left_value)
    return right_index - left_index
    
#리스트 선언
a = [1, 2, 3, 3, 3, 3, 4, 4, 8, 9]

#값이 4인 데이터 개수 출력
print(count_by_range(a, 4, 4))

#값이 [-1, 3] 범위에 있는 데이터 개수 출력
print(count_by_range(a, -1, 3))
```
```
2
6
```


**collections**

파이썬의 collections 라이브러리는 유용한 자료구조를 제공하는 표준 라이브러리다. collections 라이브러리의 기능 중에서 코딩 테스트에서 유용하게 사용되는 클래스는 deque와 counter이다.

보통 파이썬에서는 deque를 이용해 큐를 구현한다.
별도로 제공되는 Queue 라이브러리가 있는데 일반적인 큐 자료구조를 구현하는 라이브러리는 아니다. 따라서 deque를 이용해 큐를 구현해야 한다는 점을 기억하자.

기본 리스트 자료형은 데이터 삽입, 삭제 등의 다양한 기능을 제공한다.
리스트가 있을 때 중간에 특정한 원소를 삽입하는 것도 가능하다.
하지만 리스트 자료형은 append() 메서드로 데이터를 추가하거나 pop() 메서드로 데이터를 삭제할 때 '가장 뒤쪽 원소'를 기준으로 수행된다.
따라서 앞쪽에 있는 원소를 처리할 때에는 리스트에 포함된 데이터의 개수에 따라서 많은 시간이 소요될 수 있다.

리스트에서 앞쪽에 있는 원소를 삭제하거나 앞쪽의 새 원소를 삽입할 때의 시간 복잡도는 O(N)이다.

가장 앞쪽의 원소 추가 -> 리스트-O(N)/deque-O(1)
가장 뒤쪽에 원소 추가 -> 리스트-O(1)/deque-O(1)
가장 앞쪽에 있는 원소 제거 -> 리스트-O(N)/deque-O(1)
가장 뒤쪽에 있는 원소 제거 -> 리스트-O(1)/deque-O(1)

deque에서는 리스트 자료형과 다르게 인덱싱, 슬라이싱 등의 기능은 사용할 수 없다. 다만, 연속적으로 나열된 데이터의 시작 부분이나 끝부분에 데이터를 삽입하거나 삭제할 때는 매우 효과적으로 사용될 수 있다.
deque는 스택이나 큐의 기능을 모두 포함한다고도 볼 수 있기 때문에 스택 혹은 큐 자료구조의 대용으로 사용될 수 있다.

deque는 첫 번째 원소를 제거할 때 popleft()를 사용하며, 마지막 원소를 제거할 때 pop()을 사용한다. 또한 첫 번째 인덱스에 원소 x를 삽입할 때 appendleft(x)를 사용하며, 마지막 인덱스에 원소를 삽입할 때 append(x)를 사용한다.

```
from collections import deque

data = deque([2, 3, 4])
data.appendleft(1)
data.append(5)

print(data)
print(list(data))
```
```
deque([1, 2, 3, 4, 5])
[1, 2, 3, 4, 5]
```

파이썬 collections 라이브러리의 Counter는 등장 횟수를 세는 기능을 제공한다. 구체적으로 리스트와 같은 iterable 객체가 주어졌을 때, 해당 객체 내부의 원소가 몇 번씩 등장했는지를 알려준다. 따라서 원소별 등장 횟수를 세는 기능이 필요할 때 짧은 소스코드로 이를 구현할 수 있다.
```
from collections import Counter

counter = Counter(['red','blue','red','green','blue','blue'])

print(counter['blue'])
print(counter['green'])
print(dict(counter))
```
```
3
1
{'red': 2, 'blue': 3,'green': 1}
```


**mate**
자주 사용되는 수학적인 기능을 포함하고 있는 라이브러리이다.
팩토리얼,제곱근,최대공약수 등을 계산해주는 기능을 포함하고 있으므로, 수학 계산을 요구하는 문제를 만났을 때 효과적으로 사용될 수 있다.

먼저 math 라이브러리의 factorial(x) 함수는 x! 값을 반환한다.
```
import math

print(math.factorial(5))
```
```
120
```

math 라이브러리의 sqrt(x) 함수는 x의 제곱근을 의미한다.
```
import math

print(math.sqrt(7))
```
```
2.6457513110645907
```

최대 공약수를 구해야 할 때는 math 라이브러리의 gcd(a,b)함수를 이용한다. 이 함수는 a와 b의 최대 공약수를 반환한다.
```
import math

print(math.gcd(21, 14))
```
```
7
```

수학 공식에서 자주 사용하는 상수가 필요할 때에도 math 라이브러리를 사용할 수 있다. math 라이브러리는 파이나 자연상수를 제공한다.
```
import math

print(math.pi)
print(math.e)
```
```
3.141592653589793
2.718281828459045
```

