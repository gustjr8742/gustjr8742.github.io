#### 그리디 알고리즘


그리디 알고리즘은 단순하지만 강력한 문제 해결 방법이다.

이 알고리즘 유형은 국내 알고리즘 교재에서 '탐욕법'으로 소개된다.
이름에서 알 수 있듯이 어떠한 문제가 있을 때 단순 무식하게,
탐욕적으로 문제를 푸는 알고리즘이다.
'현재 상황에서 지금 당장 좋은 것만 고르는 방법' 을 뜻한다.



보통 코딩 테스트에서 출제되는 그리디 알고리즘 유형의 문제는 창의력, 즉 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력을 요구한다.

다시말해, 특정한 문제를 만났을 때 단순히 현재 상황에서 가장 좋아 보이는 것만을 선택해도 문제를 풀 수 있는지를 파악할 수 있어야 한다.

그리디 알고리즘은 기준에 따라 좋은 것을 선택하는 알고리즘이므로
이 문제에서 '가장 큰 순서대로','가장 작은 순서대로' 와 같은 기준을 알게모르게 제시해준다.

대체로 그리디 알고리즘은 정렬 알고리즘과 짝을 이루어 출제된다.

대표적인 예제문제인 '거스름 돈' 문제로 그리디 알고리즘을 생각해보자.


_ _ _

문제 : 카운터에는 거스름돈으로 사용할 500원, 100원, 50원, 10원짜리 동전이 무한히 존재한다고 가정한다. 손님에게 거슬러 줘야 할 돈이 N원일 때 거슬러 줘야 할 동전의 최소 개수를 구하라.
(단, 거슬러 줘야 할 돈 N은 항상 10의 배수이다.)


문제 해설 : 이 문제의 핵심은 바로 ' 가장 큰 화폐 단위부터' 라는 뜻을 알아야 한다.

N원을 거슬러 줘야 할 때, 가장 먼저 500원으로 거슬러주고 그다음 100원, 그다음 50원 등등...
이렇게 거슬러주면 최소의 동전 개수로 모두 거슬러 줄 수 있다.

예를 들어 입력으로 주어진 N이 1,260이라면 500원 2개, 100원 2개, 50원 1개 ,10원 1개로
총 동전의 개수는 6개 이다.

이 내용을 파이썬으로 작성하면 다음과 같다.

```
n = 1260
count = 0

coin_types = [500, 100, 50, 10]

for coin in coin_types:
    count += n // coin
    n %= coin

print(count)
```

코드를 보면 화폐의 종류만큼 반복을 수행해야 한다.
따라서 화폐의 종류가 K개라고 할 때 위 소스 코드의 시간 복잡도는 O(K)이다.
즉, 이 알고리즘의 시간 복잡도는 동전의 총 종류에만 영향을 받고, 거슬러 줘야 하는 금액의 크기와는 무관하다는 것을 알 수 있다.

(이 문제는 코딩 테스트에 나오는 문제보다는 훨씬 쉬운 문제이긴 하다.)

_ _ _

그렇다면 그리디 알고리즘은 모든 알고리즘에서 정당할까? 답은 당연히 아니오다.
'최적의 해'를 찾을 수 없는 경우가 훨씬 많다고 생각한다.
이 문제를 그리디 알고리즘으로 해결할 수 있었던 이유는 다음과 같다.

**"가지고 있는 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없기 때문이다."**

예를 들어 800원을 거슬러줘야 하는데, 회폐 단위가 500,400,100원이라고 해보자.
그렇다면 그리디 알고리즘대로 푼다면 500원 , 100원, 100원, 100원으로 총 4개의 동전이 필요하다.

하지만 우리는 400원짜리 2개를 거슬러 주는게 가장 작은 수의 동전으로 거슬러 준다는 것을 안다.

위에서 500원 100원 50원 10원 의 화폐단위는 큰 단위가 작은 단위의 배수 형태이므로,

'가장 큰 단위의 화폐부터 가장 작은 단위의 화폐까지 차례대로 확인하여 거슬러 주는 작업만을 수행하면 된다'는 아이디어는 정당하다.

**대부분의 그리디 알고리즘 문제에서는 이처럼 문제 풀이를 위한 최소한의 아이디어를 떠올리고 이것이 정당한지 검토할 수 있어야 답을 도출할 수 있다.**


