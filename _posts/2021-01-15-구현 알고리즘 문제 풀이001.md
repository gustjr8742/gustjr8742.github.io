#### 구현 알고리즘 문제풀이 001

대표적인 예제 상하좌우 문제

여행가 A는 NxN 크기의 정사각형 공간 위에 서 있다.
이 공간은 1 x 1 크기의 정사각형으로 나누어져 있다.
가장 왼쪽 위 좌표는 (1,1)이며, 가장 오른쪽 아래 좌표는(N,N)이다.
여행가 A는 상, 하, 좌, 우 방향으로 이동할 수 있으며, 시작 좌표는 항상 (1,1)이다.
우리 앞에는 여행가 A가 이동할 계획이 적힌 계획서가 놓여져 있다.

계획서에는 하나의 줄에 띄어쓰기를 기준으로 하여 L, R, U, D 중 하나의 문자가 반복적으로 적혀 있다. 각 문자의 의미는 다음과 같다.
- L : 왼쪽으로 한 칸 이동
- R : 오른쪽으로 한 칸 이동
- U : 위로 한 칸 이동
- D : 아래로 한 칸 이동

이때 여행가 A가 N x N 크기의 정사각형 공간을 벗어나는 움직임은 무시된다.
예를 들어 (1, 1)의 위치에서 L혹은 U를 만나면 무시된다.

계획서가 주어졌을 때 여행가 A가 최종적으로 도착할 지점의 좌표를 출력하는 프로그램을 작성하시오

입력 조건
- 첫째 줄에 공간의 크기를 나타내는 N이 주어진다.(1<= N <=100)
- 둘째 줄에 여행가 A가 이동할 계획서 내용이 주어진다.(1<= 이동 횟수 <=100)

출력 조건
- 첫째 줄에 여행가 A가 최종적으로 도착할 지점의 좌표 (X,Y)를 공백으로 구분하여 출력한다.

입력 예시
```
5
R R R U D D
```
출력 예시
```
3 4
```

나만의 문제 풀이.

이 문제는 제대로 풀지 못했다. 그래서 결국 유튜브 강의를 보게 되었는데
지금 그 본것조차 기억이 제대로 나지 않는다. 하지만 기억을 더듬으면서 다시한번 풀이를 해보려고 한다.
```
n = int(input())
x, y = 1, 1
nx = 0
ny = 0

str = input().split()

for i in range(len(str)):
    if str[i] == 'R':
        ny += 1
    if str[i] == 'L':
        ny -= 1
    if str[i] == 'U':
        nx -= 1
    if str[i] == 'D':
        nx += 1
    
    if 1< nx + x < n :
        x += nx
        nx = 0
    else :
        nx = 0
        
    if 1< ny + y < n :
        y += ny
        ny = 0
    else :
        ny = 0



print(x, y)
    
```

이렇게 한다면 제대로 된 답이 나온다. 문제를 한번 보고 난 후에 다시 풀어보니 이런식으로라도 해답을 찾게 된다. 하지만 이건 좀 문제 풀이가 깔끔하지 못하다.
앞서 구현 알고리즘으로 정리해둔 dx, dy같은 형식으로 풀이하지도 못하였고
if 문이 너무 많이 들어가 있다.. 만약 비슷한 문제가 나온다면 시간복잡도도 떨어질 것 같다;

그레서 문제풀이를 보고 이런 문제를 풀이하는 유형을 익히자!

**문제 해설**

이 문제를 요구사항대로 구현하면 연산 횟수는 이동 횟수에 비례하므로 시간 복잡도는 O(N)이다. 이러한 문제는 일련의 명령에 따라서 개체를 차례대로 이동시킨다는 점에서 시뮬레이션 유형으로 분류되며 구현이 중요한 대표적인 문제 유형이다.

코딩 테스트나 알고리즘 대회에서 가장 난이도가 낮은 1 ~ 2 번 문제는 대부분 그리디 알고리즘이나 구현 문제이다. 이 두 유형이 논리적 사고력을 확인할 수 있는 가장 기본 난이도의 문제로 적합하기 때문이다.
난이도가 낮은 만큼 합격을 좌우하는 중요한 문제이기도 하다.

```
# N을 입력받기


n = int(input())
x, y = 1, 1
plans = input().split()

# L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L','R','U','D']

# 이동 계획을 하나씩 확인
for plan in plans :
    # 이동 후 좌표 구하기
    for i in range(len(move_types)):
        if plan == move_types[i]:
            nx = x + dx[i]
            ny = y + dy[i]
        # 공간을 벗어나는 경우 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
        continue
        # 이동 수행
    x, y = nx, ny

print(x, y)
```
