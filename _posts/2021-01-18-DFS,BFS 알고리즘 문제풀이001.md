#### DFS/BFS 알고리즘 문제풀이 001

음료수 얼려 먹기

NxM 크기의 얼음 틀이 있따. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된다. 구멍이 뚫려 있는 부분끼리 상,하,좌,우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성하시오. 다음의 4 x 5 얼음 틀예시에서는 아이스크림이 총 3개 생성된다

입력 조건
- 첫 번재 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다 (1<= n,m <= 1,000)
- 두 번째 줄부터 N+1 번째 줄까지 얼음 틀의 형태가 주어진다.
- 이때 구멍이 뚫려있는 부분은0, 그렇지 않은 부분은 1이다.

출력 조건
- 한번에 만들 수 있는 아이스크림의 개수를 출력한다.

입력 예시
```
4 5
00110
00011
11111
00000
```
출력 예시
```
3
```


**나만의 문제 풀이 접근**

이 문제는 전형적인 DFS 문제이다.
이 문제를 처음 접했을 때, n과 m을 각각 먼저 받아야 된다고 생각했다.
```
n, m = map(int,input().split())
```

이후 그래프를 초기화하고 그래프를 먼저 나타내야 한다고 생각했다.
그런데 이 초기화하는 방법을 몰랐다. 문제는 다음과 같이 풀이해야한다는 것을 배웠다.
```
graph = []
for i in range(n):
    graph.append(list(map(int,input()))
```
이렇게 정리를 해두면 다음번에 비슷한 문제가 나왔을 때 풀이하기 용이할 거라 생각한다.

지금 위의 코드는 2차원 리스트의 맵 정보를 입력받는 형태이다.
```
#예를들어 n이 4이고 m이 5 이면
4 5
00110
00001
01010
11111
```
이런식으로 입력받을 값들을 graph에 초기화하는 방법을 나타낸 것이다.

이후 이 문제는 하나의 노드를 탐색하고, 그 노드의 상하좌우를 탐색하면서 인접한 노드가 0인 경우 그리고, 아직 방문하지 않은 지점이 있다면 해당 지점을 방문한다.

방문한 지점 중에서 다시 상하좌우를 살피고 방문을 다시 진행하면 연결된 모든 지점을 확인할 수 있다.

이 부분의 소스코드는 다음과 같다.
```
def dfs(x, y):
    # 주어진 범위를 벗어나는 경우에는 즉시 종료
    if x <= -1 or x >= n or y <= -1 or y >= m:
        return False
    # 현재 노드를 아직 방문하지 않았다면
    if graph[x][y] == 0:
        # 현재 노드를 방문 처리
        graph[x][y] = 1
        # 상, 하, 좌, 우의 위치도 모두 재귀적으로 호출
        dfs(x - 1, y)
        dfs(x, y - 1)
        dfs(x + 1, y)
        dfs(x, y + 1)
        return True
    return False
```
이 문제의 접근방법의 핵심이라고 볼 수 있는 소스코드는 위의 소스코드이다.

문제를 풀이 못했으므로 완벽하게 이해하고 해석한 뒤에 넘어가자.

- 우선 def dfs(x, y): 로 함수를 정의한다.
- 이후 만약 x나 y가 NxM의 범위를 넘어간다면 바로 함수를 종료한다.
- ==특정한 노드를 방문하여(여기서는 0,0부터 방문할것이다.) 그 노드가 0인경우 즉, 해당 노드를 아직 방문하지 않은 경우 해당 노드를 방문처리한다.==
- 이후 재귀함수를 생각하면서 상,하,좌,우의 위치도 모두 재귀적으로 호출한다.

여기서 가장 중요한 부분을 보자.
0을 아직 방문하지 않았다고 생각하는 것이고, 1은 방문했다고 생각하는 것이다.
0을 0인 상태로 냅두고 문제를 풀기에는 어렵다. 즉, 0을 1로 바꾸면서 1이라는 숫자는 방문을 했다는 숫자로 인식하면서 문제를 풀이한다는 것이다.

그렇게 모든 숫자를 탐색하면서 상,하,좌,우를 탐색하고, 만약 상,하,좌,우가 전부 1인 경우에는 False값이 반환되면서 그 함수는 종료될 것이다.

여기서 한번 더 생각한다. =='그러면 모든 노드에 대해서 1인지 확인해야할 필요가 있겠네?'==

그래서 이중 반복문을 이용하여 모든 노드를 검색한다.
```
# 모든 노드에 대하여 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
    # 현재 위치에서 DFS 수행
    if dfs(i, j) == True:
        result += 1

print(result) # 정답 출력
```

마지막 코드는 위와 같은데, 이건 아마 쉽게 예상할 수 있을거라 생각한다.

즉, 이 문제를 내가 못푼 이유는 3가지이다.(사실 이게 전부다.)
- 2차원 리스트의 맵 정보 입력받는 방법을 모름
- 특정한 노드를 방문한 후 연결된 모든 노드 방문
- 방문한 노드를 1로 바꿔가면서 하면 쉽게 풀린다는 사실

이 정보만 제대로 할줄 알았어도 풀이를 진행할 수 있었을 것이다.
다음 문제에 꼭 도움이 되리라 생각하면서 전체 답안을 올리고 마무리하겠다.
```
# n, m을 공백으로 구분하여 입력받기
n, m = map(int, input().split())

# 2차원 리스트의 맵 정보 입력받기
graph = []
for i in range(n):
    graph.append(list(map(int, input())))
    
#DFS로 특정한 노드를 방문한 뒤에 연결된 모든 노드들도 방문
def dfs(x, y):
    # 주어진 범위를 벗어나는 경우에는 즉시 종료
    if x <= -1 or x >= n or y <= -1 or y >= m:
        return False
    # 현재 노드를 아직 방문하지 않았다면
    if graph[x][y] == 0:
        # 해당 노드 방문 처리
        graph[x][y] = 1
        # 상,하,좌,우의 위치도 모두 재귀적으로 호출
        dfs(x - 1, y)
        dfs(x, y - 1)
        dfs(x + 1, y)
        dfs(x, y + 1)
        return True
    return False
    
# 모든 노드(위치)에 대하여 음료수 채우기
result = 0
for i in range(n):
    for j in range(m):
        # 현재 위치에서 DFS 수행:
        if dfs(i, j) == True:
            result += 1

print(result)
```