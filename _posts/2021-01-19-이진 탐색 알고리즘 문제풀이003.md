#### 이진 탐색 알고리즘 문제풀이003

문제 : 정렬된 배열에서 특정 수의 개수 구하기

N개의 원소를 포함하고 있는 수열이 오름차순으로 정렬되어 있다.
이때 이 수열에서 x가 등장하는 횟수를 계산해라
예를 들어 수열 [1, 1, 2, 2, 2, 2, 3]이 있을 때 x = 2라면, 현재 수열에서
값이 2인 원소가 4개이므로 4를 출력한다.

단, 이 문제는 시간 복잡도 O(logN)으로 알고리즘을 설계하지 않으면 '시간 초과'판정을 받는다.

입력 조건
- 첫째 줄에 N과 x가 정수 형태로 공백으로 구분되어 입력된다.
- (1 <= N <= 1,000,000), (-10^9 <= x <= 10^9)
- 둘째 줄에 N개의 원소가 정수 형태로 공백으로 구분되어 입력된다.

출력 조건
- 수열의 원소 중에서 값이 x인 원소의 개수를 출력한다. 단 값이 x인 원소가 하나도 없다면 -1을 출력한다.

입력 예시
```
7 2
1 1 2 2 2 2 3
```
출력 예시
```
4
```
입력 예시2
```
7 4
1 1 2 2 2 2 3
```
출력 예시2
```
-1
```

**나만의 문제 풀이**

이 문제를 접했을때 숫자가 큰 것을 보고 이진 탐색 알고리즘이구나! 라고 생각하면 좋다고 책의 저자가 이야기하였다. 근데 아마 bisect 함수로도 하면 되지 않을까 ? 라는 생각도 들었다.

그래서 우선 bisect 함수로 문제를 풀어보았다.
```
from bisect import bisect_left, bisect_right 
n, x = map(int,input().split())

array = list(map(int,input().split()))

def count_by_range(a, left_value, right_value):
    right_index = bisect_right(a, right_value)
    left_index = bisect_left(a, left_value)
    return right_index - left_index

if count_by_range(array, x, x) == 0:
    print("-1")
else:
    print(count_by_range(array, x, x))
```

물론 이 문제가 이렇게 풀이를 하라고 준 문제는 아닐거라 생각한다.
만약 라이브러리를 사용하지 못한다면 어떻게 풀이를 해야할까? 라는 생각도 가지고 있어야한다.

과연 유튜브에서는 어떻게 가르쳤는지 소스코드를 살펴보자.

** 문제 해결 아이디어 with 유튜버 나동빈 **
이 문제는 기본적으로 시간 복잡도 O(logN)으로 동작하는 알고리즘을 요구하고 있다.
일반적인 선형 탐색으로는 시간 초과 판정을 받는다.
하지만 데이터가 정렬되어 있기 때문에 이진 탐색을 수행할 수 있다.
특정 값이 등장하는 첫 번째 위치와 마지막 위치를 찾아 위치 차이를 계산해 문제를 해결할 수 있다.

유튜브에서도 bisect을 이용하여 문제를 풀이했다. 파이썬은 이렇게 풀이해도 되는것 같다.
음.. 나중에 기회가 된다면 이진탐색으로도 풀이를 진행해보겠다.



