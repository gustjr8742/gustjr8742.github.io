#### 정렬 알고리즘

**정렬**이란 =='데이터를 특정한 기준에 따라서 순서대로 나열'하는 것을 말한다.==

정렬 알고리즘은 이진 탐색의 전처리 과정이기도 하니 제대로 알고넘어가야 한다.

정렬은 그리디 알고리즘만큼 코딩테스트에서 자주 출제되는 유형이므로 반드시 알아야 한다.
_ _ _

##### 선택 정렬

데이터가 무작위로 있을 때, 이 중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 것을 선택정렬 알고리즘이라고 한다. 즉, 가장 원시적인 방법으로써, '가장 작은 것을 선택'한다는 의미를 가지고 있다.

가장 작은 것을 선택해서 앞으로 보내는 과정을 반복해서 수행하다 보면, 전체 데이터의 정렬이 이루어진다.

파이썬으로 작성한 소스코드는 다음과 같다.

```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # 스와프

print(array)
```
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

스와프란 특정한 리스트가 주어졌을 때 두 변수의 위치를 변경하는 작업을 의미한다.
파이썬에서는 간단하게 바꿀 수 있으니 이를 알아두면 편하다.
(C언어 같은 경우, 변수 하나를 더 필요로 한다.)

```
# 0 인덱스와 1 인덱스의 원소 교체하기
array = [3, 5]
array[0], array[1] = array[1], array[0]

print(array)
```
```
[5, 3]
```

선택 정렬의 시간 복잡도는 O(N^2)이다.
알고리즘 수행 시간을 측정해서 비교하면 다음과 같다.

| 데이터의 개수 | 선택 정렬 | 퀵 정렬 | 기본 정렬 라이브러리 |
|--------|--------|
| N = 100 |0.0123초 | 0.00156초 | 0.00000753초 |
| N = 1,000 |0.354초 | 0.00343초 | 0.0000365초 |
| N = 10,000 | 15.475초 | 0.0312초 | 0.000248초 |

선택 정렬은 기본 정렬 라이브러리를 포함해 다른 정렬 알고리즘과 비교했을때 비효율적이다.
다만, 특정한 리스트에서 가장 작은 데이터를 찾는 일이 코딩 테스트에서 잦으므로 선택 정렬 소스코드에 익숙해질 필요가 있다.


_ _ _

#### 삽입 정렬

삽업 정렬은 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 삽입 정렬이라고 부른다.
더불어 삽입 정렬은 특정한 데이터가 적절한 위치에 들어가기 이전에, 그 앞까지의 데이터는 이미 정렬되어 있다고 가정한다. 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다.

소스코드는 다음과 같다.
```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1): # 인덱스 i부터 1까지 감소하며 반복하는 문법
        if array[j] < array[j - 1]:
            array[j], array[j - 1] = array[j - 1], array[j]
        else: #자기보다 작은 데이터를 만나면 그 위치에서 멈춤
            break

print(array)
```
여기서 기억해야할 점은 현재 리스트가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다는 점이다. 삽입 정렬의 시간 복잡도는 O(N^2)인데, 최선의 경우 O(N)의 시간복잡도를 가진다.


_ _ _

#### 퀵 정렬

퀵 정렬은 지금까지 배운 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다.
퀵 정렬은 기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.

퀵 정렬에서는 피벗이 사용된다. 큰 숫자와 작은 숫자를 교환할 때, 교환하기 위한 '기준'을 바로 피벗이라고 표현한다.

나머지는 그림과 같이 책으로 보는게 좋으니 '이것이 코딩 테스트다 with 파이썬'에서 마저 보도록 하자. ( 그림을 넣고 싶으나 아직 잘 할줄모르고 혹시나 문제가 생길것 같아서 하지 않았다.)

가장 널리 사용되고 있는 직관적인 형태의 퀵 정렬 소스코드를 보자.

```
array = [5, 7, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end:
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while left <= right:
        #피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        #피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and array[right] >= array[pivot]:
            right -= 1
        if left > right : # 엇갈렸다면 작은 데이터와 피벗을 교체
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터 교체
            array[left], array[right] = array[right], array[left]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right-1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array)-1)
print(array)
```

**퀵 정렬의 시간 복잡도**
선택 정렬과 삽입 정렬의 시간 복잡도는 O(N^2)이다.
퀵 정렬의 평균 시간 복잡도는 O(NlogN)이다. 앞서 다루었던 두 정렬 알고리즘에 비해 빠른편이다.
여기서 증명은 넘어가도록 한다.(코테에 필요하지 않기 때문)
하지만 조만간 증명한 내용을 한번 적어서 블로그에 정리하고자 한다.(궁금해서!)

다만, 퀵 정렬의 시간 복잡도는 평균적으로 O(NlogN)이지만 최악의 경우 시간 복잡도가O(N^2)이다. 


_ _ _

#### 계수 정렬

계수 정렬 알고리즘은 특정한 조건이 부합할 때만 사용할 수 있지만 매우 빠른 정렬 알고리즘이다.
모든 데이터가 양의 정수인 상황을 가정하고, 데이터의 개수가 N, 데이터 중 최댓값이 K일 때,
계수 정렬은 최악의 경우에도 수행 시간 O(N + K)를 보장한다.
계수 정렬은 이처럼 매우 빠르게 동작할 뿐만 아니라 원리 또한 매우 간단하다.
다만, 계수 정렬은 =='데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때'만 사용가능하다.==
예를 들어 데이터의 값이 무한한 범위를 가질 수 있는 실수형 데이터가 주어지는 경우 계수 정렬은 사용하기 어렵다.
일반적으로, 별도의 리스트를 선언하고 그 안에 정렬에 대한 정보를 담는다는 특징이 있다.
계수 정렬은 먼저 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 하나의 리스트를 생성한다. 그다음 데이터를 하나씩 확인하며 데이터의 값과 동일한 인덱스의 데이터를 1씩 증가시키면 계수정렬이 완료된다.

계수 정렬 소스코드는 다음과 같다.
```
# 모든 원소의 값이 0보다 크거나 같다고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값은 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)): #  리스트에 기록된 정렬 정보 확인
    for j in range(count[i]):
        print(i, end ='') #띄어쓰기를 구분으로 등장한 횟수만큼 인덱스 출력
```
```
0 0 1 1 2 2 3 4 5 5 6 7 8 9 9
```


_ _ _

알고리즘은 오랫동안 연구된 분야이며, 특히 정렬 알고리즘은 매우 많이 연구된 주제이다.
따라서 정렬 알고리즘 문제는 어느 정도 정해진 답이 있는, 즉 외워서 잘 풀어낼 수 있는 문제라고 할 수 있다.

파이썬은 기본 정렬 라이브러리인 sorted()함수를 제공한다. sorted()는 퀵 정렬과 동작 방식이 비슷한 병합 정렬을 기반으로 만들어졌는데, 병합 정렬은 일반적으로 퀵 정렬보다 느리지만 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다는 특징이 있다.

이러한 sorted() 함수는 리스트, 딕셔너리 자료형 등을 입력받아서 정렬된 결과를 출력한다.
집합 자료형이나 딕셔너리 자료형을 입력받아도 반환되는 결과는 리스트 자료형이다.

```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

result = sorted(array)
print(result)
```
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

리스트 변수가 하나 있을 때 내부 원소를 바로 정렬할 수도 있다.
객체의 내장 함수인 sort()를 이용하는 것인데, 이를 이용하면 별도의 정렬된 리스트가 반환되지 않고 내부 원소가 바로 정렬된다.
```
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

array.sort()
print(array)
```
```
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

또한 sorted()나 sort()를 이용할 때에는 key 매개변수를 입력으로 받을 수 있다.
key 값으로는 하나의 함수가 들어가야 하며 이는 정렬 기준이 된다.
예를 들어 리스트의 데이터가 튜플로 구성되어 있을 때, 각 데이터의 두 번째 원소를 기준으로 설정하는 경우 다음과 같은 형태의 소스코드를 작성할 수 있다.
```
array = [('바나나', 2), ('사과', 5), ('당근', 3)]

def setting(data):
    return data[1]

result = sorted(array, key=setting)
print(result)
```
```
[('바나나', 2), ('당근', 3), ('사과', 5)]
```

정렬 라이브러리는 항상 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다.
사실 정렬 라이브러리는 이미 잘 작성된 함수이므로 우리가 직접 퀵 정렬을 구현할 때보다 더욱더 효과적이다. 문제에서 별도의 요구가 없다면 단순히 정렬해야 하는 상황에서는 기본 정렬 라이브러리를 사용하고, 데이터의 범위가 한정되어 있으며 더 빠르게 동작해야 할 때는 계수 정렬을 사용하자.

코딩 테스트에서 정렬 알고리즘이 사용되는 경우는 일반적으로 3가지이다.

2. 정렬 라이브러리로 풀 수 있는 문제
- 단순히 정렬 기법을 알고 있는지 물어보는 문제로 기본 정렬 라이브러리의 사용 방법을 숙지하고 있으면 어렵지 않게 풀 수 있다.
2. 정렬 알고리즘의 원리에 대해서 물어보는 문제
- 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
3. 더 빠른 정렬이 필요한 문제
- 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다.

