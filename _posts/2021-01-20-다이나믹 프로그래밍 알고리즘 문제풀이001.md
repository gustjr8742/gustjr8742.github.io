#### 다이나믹 프로그래밍 알고리즘 문제풀이 001

정수 X가 주어질 때 정수 X에 사용할 수 있는 연산은 다음과 같이 4가지 이다.
1. X가 5로 나누어떨어지면, 5로 나눈다
2. X가 3으로 나누어 떨어지면, 3으로 나눈다.
3. X가 2로 나누어 떨어지면, 2로 나눈다.
4. X에서 1을 뺀다.

정수 X가 주어졌을때 연산 4개를 적절히 사용하여 1을 만드려고 한다.
연산을 사용하는 횟수의 최솟값을 출력하시오.

예를 들어 정수가 26이면 다음과 같이 계산해서 3번의 연산이 최솟값이다.
1. 26 - 1 = 25
2. 25 / 5 = 5
3. 5 / 5 = 1

입력 조건
- 첫째 줄에 정수 x가 주어진다.(1<= x <= 30,000)

출력 조건
- 첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

입력 예시
```
26
```
출력 예시
```
3
```

_ _ _


** 문제 풀이 **
```
x = int(input())

d = [0] * 30001

for i in range(2, x + 1):
    d[i] = d[i - 1] + 1
    if i % 2 == 0:
        d[i] = min(d[i], d[i // 2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i // 3] + 1)
    if i % 5 == 0:
        d[i] = min(d[i], d[i // 5] + 1)

print[d[x]]
```

이 문제는 소스코드부터 보겠다. 왜냐하면 풀지 못했다.
되게 소스코드가 간단한데도 불구하고 아이디어를 제대로 활용하지 못하는것 같다.

지금 만약 이걸 그대로 넘어간다면 또 같은 문제가 나왔을때에도 제대로 풀이하지 못할것 같다.

그래서 지금 정리하면서 내용을 머리속에 넣어버리려고 한다.

```
d = [0] * 30001
```
이 부분은 x의 값이 1부터 30,000 이므로 어떠한 수가 들어오더라도 차례대로 저장할 수 있도록 DP 테이블을 초기화한 모습이다. 
근데 왜 30000이 아니라 30001일까... 이건 아직까지 이해가 되지 않는다.
만약 x = 30000이면 그 다음 테이블 30001에 x가 30000일때의 값을 저장해야 해서 그런건가?
맞다면 이해를 제대로 한 것이고 아니면 이해를 잘못한 것이니 문제를 계속 풀어보면서 생각해봐야겠다.

```
for i in range(2, x + 1):
    d[i] = d[i - 1] + 1
```
여기서 i의 범위는 2부터 x + 1 까지 해두었다.
x가 1일때는 바로 자신이 답이 되므로 계산하지 않아도 되서 0이고
x가 2일때는 d[2] = d[1] + 1 --> d[2] = 0 + 1 이므로 1 이다.
따라서 올바른 값이 나온다. 2부터 시작하는건 맞다.
x + 1 부분을 보자. 만약 x 가 3이라면 range(2, 4)이므로 2부터 3까지 이다. 따라서 올바르다.

d[i] = d[i - 1] + 1 이 코드를 살펴보자.
이 부분은 만약 x가 4라고 하였을때, d[4]는 d[3] +1이라는 뜻이다. 
이후 코드를 보면
```
if i % 2 == 0 :
    d[i] = min(d[i], d[i // 2] + 1)
```
이런 형식으로 되어있다.
x = 4일때 돌아가는 방식을 생각해보자.
우선 i = 2일때, d[2] = d[1] + 1 = 2
i = 3일때, d[3] = d[2] + 1 이 먼저 계산, d[3] = 3
이후, if i % 3 == 0에 걸려 d[3] = min(3, d[3 // 3] + 1)
d[3] = min(3, d[1] + 1) = min(3, 1) = 1
결국 d[3] 은 1이 된다.
d[4]를 보자.
d[4] = d[3] + 1 이 먼저 실행되어 d[4] = 2
이후 4가 if % 2 == 0: 에걸린다.
d[4] = min(d[4], d[2] + 1) = min(2, 2+ 1) = 2
따라서 d[4] 도 2가 된다.

이렇게 하나하나 생각하다보면 문제가 다 풀리게 되어있다 왜냐하면
d[1], d[2], d[3], d[4]의 값들은 변하지 않고 만약 그 값들이 필요하다면 꺼내 쓸수 있기 때문이다.(리스트로 그 값들이 저장되어 있다.)

이걸 생각하여, 문제를 풀이하면 된다. 약간 이렇게 풀이하고 나니 소스코드가 이해가 된다.

앞으로 이 문제를 다시한번 코드리뷰를 하면서 암기하고 정리하자!



