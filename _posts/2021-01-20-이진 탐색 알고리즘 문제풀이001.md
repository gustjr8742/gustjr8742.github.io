#### 이진 탐색 알고리즘 문제풀이001

부품 찾기

전자 매장에는 부품이 N개 있다. 각 부품은 정수 형태의 고유한 번호가 있다. 어느 날 손님이 M개 종류의 부품을 대량으로 구매하겠다며 당일 날 견적서를 요청했다. 때를 놓치지 않고 손님이 문의한 부품 M개 종류를 모두 확인해서 견적서를 작성해야 한다. 이때 가게 안에 부품이 모두 있는지 확인하는 프로그램을 작성해보자.

예를 들어 가게의 부품이 5개일때 부품 번호가 다음과 같다고 하자
```
n = 5
[8, 3, 7, 9, 2]
```
손님은 총 3개의 부품을 요청하고 부품 번호는 다음과 같다.
```
m = 3
[5, 7, 9]
```
이때 손님이 요청한 부품 번호의 순서대로 부품을 확인해 있으면 yes, 없으면 no를 출력한다.
구분은 공백으로 한다.
입력 조건
- 첫째 줄에 정수 N이 주어진다.( 1 <= N <= 1,000,000)
- 둘째 줄에는 공백으로 구분하여 N개의 정수가 주어진다. 정수는 1보다 크고 1,000,000 이하이다.
- 셋째 줄에는 정수 M이 주어진다.(1 <= M <= 100,000)
- 넷째 줄에는 공백으로 구분하여 M개의 정수가 주어진다. 이때 정수는 1보다 크고 1,000,000이하이다.

출력 조건
- 첫째 줄에 공백으로 구분하여 각 부품이 존재하면 yes를, 없으면 no를 출력한다.

입력 예시
```
5
8 3 7 9 2
3
5 7 9
```
출력 예시
```
no yes yes
```

**나만의 문제 풀이**

나는 아직 이진 탐색을 만드는데 어려움이 있는 것 같다.
제대로된 이진 탐색 풀이로 문제를 풀진 못하였다. 아무래도 이진 탐색 함수를 제대로 외우거나 관례처럼 사용할 수 있도록 풀이를 해야겠다.

내가 문제를 푼 소스코드를 보자
```
n = int(input())

array = list(map(int,input().split()))
array.sort()

m = int(input())

check = list(map(int,input().split()))

result = 'no'

for i in range(m):
    for j in range(n):
        if array[j] == check[i]:
            result = 'yes'
            break
        else:
            result = 'no'
    
    print(result, end= ' ')
```

이렇게 하면 답은 나온다. 하지만 시간 복잡도는 아마 초과를 받을 것 같다.
그리고 이렇게 하면 위의 코드에서 sort()함수를 사용할 필요가 없다.
이진 탐색을 활용하고 싶어서 써봤는데 방법이 떠오르지 않았다.

그래서 책에 예제로 나와있는 함수를 보면서 문제를 풀어본 결과 다음과 같은 소스코드가 나왔다.
```
n = int(input())

array = list(map(int,input().split()))
array.sort()

m = int(input())

check = list(map(int,input().split()))



def data_check(array, target, start, end):
    if start > end:
        return None
    mid = (start + end) // 2
    
    if array[mid] == target:
        return mid
    elif array[mid] > target:
        return data_check(array, target, start, mid - 1)
    else:
        return data_check(array, target, mid + 1, end)


for i in range(m):
    result = data_check(array, check[i], 0, n-1)
    if result == None:
        print('no', end = ' ')
    else:
        print('yes', end = ' ')
```
이 정답이 제대로 된 정답인지는 모르겠다.
따라서, 책의 풀이방법을 공부해보겠다.

** 책의 문제 해설 **

이 문제는 여러 방법으로 해결할 수 있다.
다량의 데이터 검색은 이진 탐색 알고리즘을 이용해 효과적으로 처리할 수 있다.

먼저 매장 내 N개의 부품을 번호를 기준으로 정렬한다. 이후에 M개의 찾고자 하는 부품이 각각 매장에 존재하는지 검사하면 된다. 이때 매장의 부품들은 정렬되어 있기 때문에 이진 탐색을 수행하여 찾을 수 있다.

이렇게 문제를 풀면, 부품을 찾는 과정에서 최악의 경우 시간 복잡도 O(M X logN)의 연산이 필요하므로 이론상 최대 약 200만 번의 연산이 이루어진다고 분석할 수 있다.

지금까지 배운 이진 탐색 알고리즘을 이용한 풀이는 다음의 소스코드와 같다.
```
# 이진 탐색 소스코드 구현(반복문)

def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] > target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid + 1
        return None

# 가게 부품 개수 입력
n = int(input())
# 가게에 있는 전체 부품 번호를 공백으로 구분하여 입력
array = list(map(int, input().split()))
array.sort() # 이진 탐색을 위한 정렬
# 손님이 확인 요청한 부품 개수 입력
m = int(input())
# 손님이 확인 요청한 전제 부품 번호 공백 기준 입력
x = list(map(int,input().split()))

for i in x:
    # 해당 부품이 존재하는지 확인
    result = binary_search(array, i, 0, n-1)
    if result != None:
        print('yes', end = ' ')
    else:
        print('no', end = ' ')
```

나머지 소스코드도 존재하지만 우선 이진 탐색을 완벽히 이해해야 하므로, 이 문제는 이렇게 풀이한다는 점을 기억하고 넘어가자.


* * *
###추가

이제 이진탐색으로 이 문제는 2021-01-25 풀이를 완료하였다.
앞부분을 복습하고 공부한뒤에 다시 이진탐색을 이용하여 풀이를 진행한 결과, 동일한 소스코드로 풀 수 있었다.

이제 하나의 스킬을 배우고 넘어가보자.

이 문제는 사실, 집합자료형을 머리속에 넣고 있었다면 간단하게 풀이할 수 있었다.

==우선 집합자료형에 대해 알아보자.==

집합(set)은 순서가 없고, 인덱스가 없는 모음으로, 파이썬 2.3부터 지원되는 자료형이다.
집합 자료형을 생성하려면 set 명령어를 사용해서 아래와 같이 집합 자료형을 생성할 수 있다.
```
A = set([4, 5, 1])
B = set('abc')
```
```
set([1, 4, 5])
set(['a', 'c', 'b'])
```

A는 리스트를 입력으로 받아서 set 자료형을 만들었고, B는 문자열을 입력받았다.
그런데 문자열의 경우에는 해당 문자열을 낱개로 쪼개어 각각의 문자들을 하나의 인자로 인식하여 집합을 만들었다.
여기서 첫 번째 집합 자료형의 특징을 확인할 수 있다.
- 집합 자료형은 순서를 가지지 않는다.

그럼 다음 예제를 보자
```
A = set('abbbc')
print(A)
```
```
set(['a', 'c', 'b']) # 순서는 바뀔수 있음
```
여기서 보면, b가 세번 들어갔음에도, 두번의 b가 생략되는 것을 볼 수 있다.
여기서 또하나 특징을 발견할 수 있다.
- 집합 자료형은 중복을 허용하지 않는다.

또한, 다음의 예제를 보면 바로 알수있는것이 있다.
```
A = set('abbbc')
print(A[0])
```
```
에러
```
set 객체는 인덱싱을 지원하지 않는다는 에러가 뜬다.
- 집합 지료형은 인덱싱이 되지 않는다.


간단하게 집합 자료형에 대해 알아보았는데, 이 특징들을 나열하면 다음과 같다.
- 집합 자료형은 순서를 가지지 않는다.
- 집합 자료형은 중복을 허용하지 않는다.
- 집합 자료형은 인덱싱이 되지 않는다.

이렇게 간단하게만 알고 있어도 아주 손쉽게 이 문제를 해결할 수 있다.

자 이제 집합자료형으로 풀이한 소스코드를 보자.
```
#가게의 부품 개수를 입력받기
n = int(input())
# 가게에 있는 전체 부품 번호를 입력받아서 집합 자료형에 기록
array = set(map(int, input().split()))

#손님이 요청한 부품 개수 입력받기
m = int(input())
#손님이 확인 요청한 부품 번호를 공백으로 입력
x = list(map(int, input().split()))

for i in x:
    if i in array:
        print('yes', end= ' ')
    else:
        print('no', end = ' ')
```

이렇게 아주 손쉽게 문제를 풀이할 수 있다.
물론 이 부분은 이진 탐색과는 약간 관계가 멀게 느껴질 수 있으므로, 이진 탐색을 마무리하고
집합 자료형에 대해 이해하도록 노력해보자!

