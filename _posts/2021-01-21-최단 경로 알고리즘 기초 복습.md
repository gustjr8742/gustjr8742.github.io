### 최단 경로, 다이나믹 프로그래밍 기초 복습

2021-01-20, 2021-01-21 이렇게, 다이나믹 프로그래밍과 최단 경로를 공부하였다.

아무리 생각해도 프로그래밍에 있어서 가장 중요한건 기초적인 내용인것 같다고 생각이 든다.
지금 나는 다이나믹 프로그래밍과 최단 경로에 대한 기초가 매우 부족하다.

유튜브를 보면서 공부를 진행했지만 문제를 풀때 바로 막혀버린다. 애초에 아이디어조차 떠오르지 않는다. 많은 문제를 접해보면 풀릴지도 모르지만, 이렇게 모른 상태로 계속 있는게 싫기 때문에 다시한번 정리를 진행하고 많은 문제를 풀어보려고 한다.
(물론 지금까지 배운 모든 알고리즘에 익숙해지기 위해 다양하게 풀 예정이다.)

그럼 오늘 배운 최단 경로부터 다시 공부를 진행하자.


_ _ _

#### 최단 경로 알고리즘

최단 경로 알고리즘은 말 그대로 가장 짧은 경로를 찾는 알고리즘이다.
그래서 길찾기 문제라고도 불린다.
이 알고리즘도 많이 풀어봐야 하는 이유는 이미 상황에 맞는 효율적인 알고리즘이 정립되어 있기 때문이다.

예를 들어 ' 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야 하는 경우.'
' 모든 지점에서 다른 모든 지점까지 최단 경로를 모두 구해야 하는 경우' 등의 다양한 사례가 있다.

최단 경로 문제는 각 지점은 그래프에서 **==노드==**로 표현되고, 지점간 연결된 도로는 **==간선==**으로 표현된다.

컴퓨터공학과 학부 수준에서는 다익스트라,플로이드 워셜, 벨만 포드 이렇게 3가지가 있는데,
그중 다익스트라와 플로이드 워셜이 가장 많이 코딩테스트에 나오므로 이 두가지를 책에서 배운다.
(나중에 벨만 포드도 공부해둬야겠다. 많이 나오지 않는다고 해서 꼭 안나오는건 아니므로!!)


##### 다익스트라 최단 경로 알고리즘

다익스트라 최단 경로 알고리즘은 그래프에서 여러 개의 노드가 있을 때, 특정한 노드에서 출발하여 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘이다.
(단, 음의 간선이 없을때만 정상적으로 동작한다.)

다익스트라 최단 경로 알고리즘은 기본적으로 그리디 알고리즘으로 분류되는데, 그 이유는 매번 =='가장 비용이 적은 노드'==를 선택해서 임의의 과정을 반복하기 때문이다.

알고리즘의 원리는 다음과 같다.
1. 출발 노드를 설정한다.
2. 최단 거리 테이블을 초기화 한다.
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택한다.
4. 해당 노드를 거쳐 다른 노드로 가능 비용을 계산하여 최단 거리 테이블을 갱신한다.
5. 위 과정에서 3번과 4번을 반복한다.

다익스트라 알고리즘은 최단 경로를 구하는 과정에서 '각 노드에 대한 현재까지의 최단 거리'정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있다.

'방문하지 않은 노드 중에서 현재 최단 거리가 가장 짧은 노드를 확인'하여 그 노드에 대하여4번을 수행하는 점이 그리디 알고리즘으로 분류된다는 점도 있다.

다익스트라 알고리즘은 2가지 구현 방법이 있다.
1. 구현하기 쉽지만 느리게 동작하는 코드
2. 구현하기 까다롭지만 빠르게 동작하는 코드

코딩 테스트에 준비하는 사람이라면 자다가도 일어나서 바로 코드를 작성할 수 있을 정도로 코드에 숙달되어야 한다고 한다.(특히 2번)
만약 이를 알게 된다면 다양한 고난이도 문제를 만났을 때에도 도움을 얻을 수 있다.
우선 책에서 그림으로 설명된 다익스트라 알고리즘을 보고 글로 풀어서 이해하려고 한다.

**책에서 그림으로 설명된 내용을 내가 직접 글로 풀어쓰면서 이해해보자.**

예를 들어, 노드가 총 5개가 있다고 가정하자.
[1, 2, 3, 4, 5]

출발 노드를 1이라고 가정하자.
여기서 1번 노드가 갈 수 있는 수는 2,3,4,5 로 각각 간선의 크기는 1,2,3,4 이라고 하자.
그럼 최단 거리 테이블은 각각 0,1,2,3,INF로 초기화된다.(여기서 INF는 무한이다.)

그 다음 이제 최단 거리 테이블에서 가장 작은 값을 선택한다.(선택되었던 것은 제외)
그럼 1인데 1의 노드는 2이다. 2에서 출발하여 갈 수 있는 노드는 3,4 이고 간선의 크기는 1,1이라고 가정해보자.

그럼 이제 1에서 2를 거쳐서 3으로 갈 수 있는 간선의 크기는 1(1에서 2로)+1(2에서 3으로)해서 총 2다. 1에서 3으로 가는 비용은 2이고, 1에서 2를 거쳐 3으로 가는 비용도 2다.
그러므로 변화가 없다.
다음, 1에서 2를 거쳐 4를 가는 비용은 1(1에서 2로) +1(2에서 4로) 해서 2이다.
근데 1에서 4로 가는 비용은 3이므로 이 경우에는 2를 거처서 4로 가는 경우가 더 짧다.
따라서 테이블 값을 변경한다. 그럼 이제 테이블 값은 다음과 같이 된다.
[0,1,2,2,INF]
이런식으로 계속 나아가면서 값을 바꾸는 방식이다. 이게 바로 다익스트라 최단 경로 알고리즘이다.

그럼 이제 소스코드를 보면서 해석해보자.
```
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 설정

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
# 시작 노드 번호를 입력받기.
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트 만들기
graph = [[] for i in range(n + 1) ]
# 방문한 적이 있는지 체크하는 목적의 리스트를 만들기
visited = [False] * (n + 1)
# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기.
for _ in range(m):
    a, b, c = map(int, input().split())
    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b, c))
    
# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node():
    min_value = INF
    index = 0 # 가장 최단 거리가 짧은 노드(인덱스)
    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    # 시작 노드에 대해서 초기화
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]
    # 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
    for i in range(n - 1):
        # 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
        now = get_smallest_node()
        visited[now] = True
        # 현재 노드와 연결된 다른 노드를 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            # 현재 노드를 거쳐서 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]]:
                distance[j[0]] = cost
# 다익스트라 알고리즘 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    # 도달할 수 없는 경우, 무한이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    # 도달할 수 있는 경우 거리를 출력
    else:
        print(distance[i])
```
입력 예시
```
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
```
출력 예시
```
0
2
3
1
2
4
```

우선 한번 코드를 작성하는걸 책을 보며 작성해보았다. 이제 하나씩 해석해가며 아 이게 이런 소스코드구나하고 이해한 뒤에 작성하는건 계속 연습해보도록 한다.
(이해 못하는 소스가 있다는건 내가 습득하지 못했다는 증거이므로 정리해보자.)
(만약 이해를 하지 못하면 할 때까지 외우거나 다시 복습하겠다.)

```
import sys
input = sys.stdin.readline
INF = int(1e9)
```
여기서 import로 sys를 선언하고 input을 sys.stdin.readline을 한 이유는 무엇일까
검색해본결과, input()보다 sys.stdin.readline()이 훨씬 가볍고 빠르다.
그래서 백준같은 사이트에서 input()을 이용하여 푸는 것보다 sys.stdin.readline()을 이용하는것 만으로도 시간초과 판정을 받지 않는 경우도 많다고 한다.

이 문제같은 경우도 값이 늘어나면 시간이 많이 소요되기 때문에 시간복잡도를 생각하여 이렇게 작성한 것 같다.

그리고 INF = int(1e9)는 그냥 무한 값을 정수로 표현한 값을 의미한다.

```
n, m = map(int, input().split())
start = int(input())
graph = [[] for i range(n + 1)]
visited = [False] * (n + 1)
distance = [INF] * (n + 1)
```

자 이 코드를 해석해보자.
우선 n,m은 노드의 개수, 간선의 개수를 입력받는 것을 의미한다.
start 는 시작 노드 번호를 입력받는 것이고
graph 는 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만드는 것이다.
visited는 방문한 적이 있는지 체크하는 목적의 리스트를 만드는 것이다.
(방문한 적이 있으면 True로 변환되는데, 이 값은 뒤에 나온다.)
distance 는 거리를 의미하는데 아직 다익스트라 알고리즘이 시작되지 않았으니 모든 값을 INF로 초기화 한 상태로 진행한다.

```
for _ in range(m):
    a, b, c = map(int, input().split())
    graph[a].append((b, c))
```
이 코드를 보면 graph[a].append((b, c))가 있다. 이건 a번 노드에서 b번 노드로 가는 비용이 c라는 의미이다.

그리고 for _ in range(m)은 변수를 지정하지 않고 m번 반복한다는 뜻인데,
여기서 보면 m은 간선의 갯수이므로, 간선의 갯수가 몇개냐에 따라 몇번 반복되는지 결정된다.
즉 모든 간선의 값을 저장해야 사용할 수 있기 때문에 다음과 같이 나타낸 것이다.

이제 graph에 각 노드에 연결되어 있는 노드에 대한 정보가 담겨있다.

```
def get_smallest_node():
    min_value = INF
    index = 0
    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
        min_value = distance[i]
        index = i
    return index
```
이 코드의 해석은 다음과 같다.
=='방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환'==
그러니까, min_value 함수에 INF을 우선 집어넣고, index를 0으로 선언한다.
여기서 index는 가장 최단 거리가 짧은 노드를 의미하는 것이므로 우선 0으로 초기화한거 같다.

그리고 for 문을 돌리는데, 1부터 n+1까지 즉, 노드 갯수만큼 for문을 돌리는것이다.
distance[i] 즉, distance[1]부터 distance[n]까지랑 min_value 랑 크기를 비교하여
min_value가 INF이므로, distance가 INF가 아니고, 방문한 적이 없다면(not visited[i])
min_value 값을 distance[i] 값으로 초기화 하고, index 값을 i로 초기화 한다.

약간 이해 안되는 부분이 존재하는데, 이제 다익스트라 알고리즘을 보고 생각해보자.
```
def dijkstra(start):
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]

    for i in range(n - 1):
        now = get_smallest_node()
        visited[now] = True

        for j in graph[now]:
            cost = distance[now] + j[1]
            if cost < distance[j[0]]:
                distance[j[0]] = cost

dijkstra(start)
```
여기 부분이 많이 헷갈리는 부분이다.

처음부터 하나씩 분해해가며 생각해보자.
```
distance[start] = 0
visited[start] = True
```
start는 사직되는 노드이다. (코드를 보면 나와있음) 즉 예제에서는 1이 start노드였으므로
여기선 1이 들어간다 생각하자.
그리고 visited를 True로 했으니 방문했다고 False값을 변경해준것이다.

```
for j in graph[start]:
    distance[j[0]] = j[1]
```

자 예상을 해보자. start는 1이다. 즉 graph[1]에 입력예시가 1 2 2 / 1 3 5/ 1 4 1 이렇게 넣어졌으니까 j[0]은 [1][0]인거고, j[1]은 [1][1]인건가?
그래서 distance[2]에 = 2 값을 넣는건가? 싶다. 초기값이니까 아마 맞지 않나...

그럼 다음 코드를 보자
```
for i in range(n - 1):
    now = get_smallest_node()
    visited[now] = True

    for j in graph[now]:
        cost = distance[now] + j[1]

        if cost < distance[j[0]]:
            distance[j[0]] = cost
```

이번엔 for문이 조금 길어서 한번에 작성하였다.
그럼 하나하나 살펴보자.

now 라는 변수에 get_smallest_node()를 호출한 값을 넣는다.
이 함수에서 리턴되는 값은 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드를 반환하므로
여기선 아마 2가 출력될 것이다. now = 2
그럼 for j in graph[2]: 가 될 것이고,
cost = distance[2] + j[1]이다. 즉, 2로 가는 비용 2에 j[1]을 더하는건데.. 음
아 너무 어렵다;;
j[1]은 아마 그래프2의 1일것이므로 아마 3인가? 뭐 이런식인것 같다.
약간 이해하는게 너무 어렵다. 차근차근 이해시켜주면서 진행하는걸 만들어 둔 사람이 있으면 좋겠다.

일단 공부를 진행하면서 다시 또 해봐야겠다..






